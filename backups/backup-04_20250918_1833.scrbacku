# T√≠tulo: PopCraft
# Descri√ß√£o: Adicionado fun√ß√µes Debug e teste.
‚îú‚îÄ‚îÄ PopCraft/
‚îî‚îÄ‚îÄ README.md
```python
<h1 align="center">üéÆ PopCraft Manager </h1>
<h3 align="center">üöÄ Gerenciador POPStarter Ultimate para PS2 üöÄ</h3>

<p align="center">
Organize, converta e gerencie sua biblioteca de jogos <b>PS1 no PlayStation 2</b> usando o <b>POPStarter</b> ‚Äî com estilo, velocidade e precis√£o! üíæüïπÔ∏è  
</p>

---

## ‚ú® Features
- ‚ö° **Convers√£o Inteligente** ‚Äî `.CHD ‚Üí .CUE+.BIN ‚Üí .VCD` (com log em tempo real ‚è±Ô∏è)  
- üìÇ **Padr√£o POPStarter Perfeito** ‚Äî `XX.SLUS_123.45.ELF`, `XX.SLUS_123.45.ELF_COV.png`  
- üîÑ **Modo Avan√ßado** ‚Äî converte entre `.CHD`, `.CUE`, `.BIN`, `.ISO`, `.VCD`  
- üñ±Ô∏è **Drag & Drop** ‚Äî adicione jogos facilmente  
- üëÄ **Preview de Capas/Logos** ‚Äî passe o mouse e veja ampliado  
- üõ°Ô∏è **Backup Autom√°tico** ‚Äî nunca perca sua `conf_apps.cfg`  
- üîç **Busca Avan√ßada + Exporta√ß√£o** ‚Äî exporte CSV, HTML, etc.  
- üé® **Modo Retro** ‚Äî ative com `Ctrl+Shift+R` (Press Start 2P inclu√≠da)  
- üõ†Ô∏è **Suporte a Fixes** ‚Äî c√≥pia autom√°tica de `_pops_fix/[ID]`  
- üìä **Logs Coloridos + Barra de Progresso**  
- üì¶ **Compila√ß√£o .EXE garantida** ‚Äî nada quebra!  

---

## üõ†Ô∏è Ferramentas Integradas
| Ferramenta       | Fun√ß√£o |
|------------------|--------|
| `chdman.exe`     | Extra√ß√£o profissional de CHD |
| `cue2pops.exe`   | Convers√£o para formato POPStarter |
| `POPS2CUE.EXE`   | Revers√£o de VCD para CUE+BIN |
| `vcd2iso.exe`    | Extra√ß√£o direta para ISO |
| `_copy` & `_pops_fix` | Personaliza√ß√£o avan√ßada de jogos |

---

## üöÄ Como Usar

```
‚îî‚îÄ‚îÄ main.py
```python
import os
from popstation_core import get_script_root, ensure_dir  # ‚úÖ IMPORTA AS FUN√á√ïES NECESS√ÅRIAS
from popstation_gui import PopsManagerGUI
from tkinterdnd2 import TkinterDnD

if __name__ == "__main__":
    # ‚úÖ Garante que a pasta de logs exista
    ensure_dir("logs")
    log_file = os.path.join("logs", "popstation.log")
    if os.path.exists(log_file):
        open(log_file, "w", encoding="utf-8").close()

    # ‚úÖ Obt√©m a pasta raiz do script
    script_root = get_script_root()
    print(f"[INFO] Pasta raiz do script: {script_root}")

    # ‚úÖ Inicia a interface gr√°fica
    root = TkinterDnD.Tk()
    app = PopsManagerGUI(root)
    root.mainloop()

```
‚îî‚îÄ‚îÄ popstation_core.py
```python
import os
import shutil
import subprocess
import tempfile
import re
import hashlib
import csv
import json
import datetime
import sys

# ---------------- Configura√ß√µes ----------------
SUPPORTED_FORMATS = ['.iso', '.bin', '.cue', '.mdf', '.ecm', '.img', '.chd', '.gdi', '.zso']
POPS_ELF_NAME = "POPS.ELF"
BIOS_FILE_NAME = "BIOS.BIN"
SLOT0_VMC_NAME = "SLOT0.VMC"
SLOT1_VMC_NAME = "SLOT1.VMC"
POPS_DIR_NAME = "POPS"
ART_DIR_NAME = "ART"
CHDMAN_EXE = "chdman.exe"
CUE2POPS_EXE = "cue2pops.exe"
POPS2CUE_EXE = "POPS2CUE.EXE"
VCD2ISO_EXE = "vcd2iso.exe"
ZISO_EXE = "ziso.exe"

# ---------------- Fun√ß√µes utilit√°rias ----------------
def get_script_root():
    if getattr(sys, 'frozen', False):
        return os.path.dirname(sys.executable)
    else:
        return os.path.dirname(os.path.abspath(__file__))

def ensure_dir(path):
    if not os.path.exists(path):
        os.makedirs(path)

def copy_file(src, dest):
    ensure_dir(os.path.dirname(dest))
    if os.path.exists(src):
        shutil.copy2(src, dest)

def copy_tree(src, dst, log_callback=None):
    """Copia recursivamente uma pasta, mantendo estrutura e sobrescrevendo apenas se necess√°rio."""
    if not os.path.exists(src):
        if log_callback: log_callback(f"‚ö†Ô∏è Pasta de origem n√£o encontrada: {src}")
        return False
    ensure_dir(dst)
    try:
        for item in os.listdir(src):
            s = os.path.join(src, item)
            d = os.path.join(dst, item)
            if os.path.isdir(s):
                if os.path.exists(d):
                    # Se pasta existe, entra recursivamente (merge)
                    copy_tree(s, d, log_callback)
                else:
                    shutil.copytree(s, d, dirs_exist_ok=False)
            else:
                # Se arquivo existe, compara conte√∫do antes de sobrescrever
                if os.path.exists(d):
                    if os.path.getsize(s) == os.path.getsize(d):
                        with open(s, 'rb') as f1, open(d, 'rb') as f2:
                            if f1.read() == f2.read():
                                if log_callback: log_callback(f"‚úÖ Ignorado (igual): {item}", "info")
                                continue
                shutil.copy2(s, d)
        if log_callback: log_callback(f"‚úÖ Copiado: {src} ‚Üí {dst}")
        return True
    except Exception as e:
        if log_callback: log_callback(f"‚ùå Erro ao copiar {src} ‚Üí {dst}: {e}")
        return False

def get_file_hash(file_path):
    """Retorna hash SHA256 dos primeiros 8 caracteres do arquivo."""
    if not os.path.exists(file_path):
        return None
    hasher = hashlib.sha256()
    try:
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hasher.update(chunk)
        return hasher.hexdigest()[:8]
    except:
        return "ERROR"

# ---------------- Convers√µes Avan√ßadas ----------------
def convert_chd_to_iso_temp(chd_path, log_callback=None, progress_callback=None):
    """Extrai CHD para CUE+BIN usando chdman.exe. Usa temp dir seguro."""
    temp_base = os.environ.get('TEMP', tempfile.gettempdir())
    temp_dir = tempfile.mkdtemp(prefix="POPSTEMP_", dir=temp_base)
    game_name = os.path.splitext(os.path.basename(chd_path))[0]
    cue_path = os.path.join(temp_dir, f"{game_name}.cue")
    bin_path = os.path.join(temp_dir, f"{game_name}.bin")
    comando = [CHDMAN_EXE, "extractcd", "-i", chd_path, "-o", cue_path, "-ob", bin_path]
    try:
        if log_callback:
            log_callback(f"‚ñ∂Ô∏è Iniciando extra√ß√£o de {os.path.basename(chd_path)}...")
        if progress_callback:
            progress_callback("Iniciando...", 0)
        process = subprocess.Popen(
            comando,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
            encoding='utf-8',
            errors='replace'
        )
        last_pct = 0
        if log_callback:
            log_callback("   Aguarde...")
        for line in process.stdout:
            line = line.strip()
            if not line:
                continue
            pct_match = re.search(r"(\d+)%", line)
            if pct_match:
                pct = int(pct_match.group(1))
                if pct != last_pct:
                    last_pct = pct
                    if progress_callback:
                        progress_callback(f"Extraindo {os.path.basename(chd_path)}", pct)
                    if log_callback:
                        log_callback(f"   {line}")
            elif "Extracting" in line or "Writing" in line or "Creating" in line:
                if log_callback:
                    log_callback(f"   {line}")
        process.wait()
        if process.returncode != 0:
            raise subprocess.CalledProcessError(process.returncode, comando)
        if log_callback:
            log_callback(f"‚úÖ Extra√ß√£o conclu√≠da: {os.path.basename(chd_path)}")
            log_callback(f"   Arquivos gerados em: {temp_dir}")
        return cue_path, bin_path, temp_dir
    except FileNotFoundError:
        if log_callback: log_callback(f"‚ùå Erro: {CHDMAN_EXE} n√£o encontrado!")
        return None, None, None
    except subprocess.CalledProcessError as e:
        if log_callback: log_callback(f"‚ùå Falha ao converter {chd_path}: c√≥digo {e.returncode}")
        if 'temp_dir' in locals():
            shutil.rmtree(temp_dir, ignore_errors=True)
        return None, None, None
    except Exception as e:
        if log_callback: log_callback(f"‚ùå Erro inesperado: {e}")
        if 'temp_dir' in locals():
            shutil.rmtree(temp_dir, ignore_errors=True)
        return None, None, None

def convert_to_vcd(source_path, output_path, log_callback=None):
    if log_callback: log_callback(f"üì¶ Criando VCD: {os.path.basename(output_path)}...")
    shutil.copy2(source_path, output_path)
    if log_callback: log_callback(f"‚úÖ VCD criado: {os.path.basename(output_path)}")
    return True

def convert_vcd_to_iso(vcd_path, output_iso, log_callback=None):
    script_root = get_script_root()
    vcd2iso_path = os.path.join(script_root, VCD2ISO_EXE)
    if not os.path.exists(vcd2iso_path):
        if log_callback: log_callback(f"‚ùå {VCD2ISO_EXE} n√£o encontrado!")
        return False
    comando = [vcd2iso_path, vcd_path, output_iso]
    try:
        if log_callback: log_callback(f"‚ñ∂Ô∏è Convertendo {os.path.basename(vcd_path)} ‚Üí ISO...")
        result = subprocess.run(comando, capture_output=True, text=True, encoding='utf-8', errors='replace')
        if result.returncode != 0:
            if log_callback: log_callback(f"‚ùå Falha: {result.stderr}")
            return False
        if log_callback: log_callback(f"‚úÖ ISO criado: {os.path.basename(output_iso)}")
        return True
    except Exception as e:
        if log_callback: log_callback(f"‚ùå Erro: {e}")
        return False

# ‚úÖ ‚úÖ ‚úÖ FUN√á√ÉO CORRIGIDA: Usa POPS2CUE.EXE para VCD ‚Üí CUE+BIN (IGNORA returncode)
def convert_vcd_to_cue_bin_with_pops2cue(vcd_path, log_callback=None):
    """
    Converte um arquivo .VCD em .CUE + .BIN usando o POPS2CUE.EXE.
    Ignora o returncode do processo e verifica apenas se os arquivos foram criados.
    Comando usado: POPS2CUE.EXE "arquivo.vcd"
    """
    script_root = get_script_root()
    pops2cue_path = os.path.join(script_root, POPS2CUE_EXE)
    if not os.path.exists(pops2cue_path):
        if log_callback: log_callback(f"‚ùå {POPS2CUE_EXE} n√£o encontrado!")
        return False
    comando = [pops2cue_path, vcd_path]
    try:
        if log_callback: log_callback(f"‚ñ∂Ô∏è Executando: {' '.join(comando)}")
        if log_callback: log_callback(f"‚ñ∂Ô∏è Convertendo {os.path.basename(vcd_path)} ‚Üí CUE+BIN...")
        process = subprocess.Popen(
            comando,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
            encoding='utf-8',
            errors='replace',
            cwd=os.path.dirname(vcd_path)
        )
        output_lines = []
        for line in process.stdout:
            line = line.strip()
            output_lines.append(line)
            if log_callback:
                log_callback(f"   {line}")
        process.wait()
        # ‚úÖ VERIFICA APENAS SE OS ARQUIVOS FORAM CRIADOS
        base_name = os.path.splitext(vcd_path)[0]
        output_cue = f"{base_name}.cue"
        output_bin = f"{base_name}.bin"
        if os.path.exists(output_cue) and os.path.exists(output_bin):
            if log_callback: log_callback(f"‚úÖ Gerado: {os.path.basename(output_cue)} + {os.path.basename(output_bin)}")
            return True
        else:
            if log_callback: log_callback(f"‚ùå Arquivos CUE/BIN n√£o foram gerados pelo POPS2CUE.EXE!")
            if log_callback: log_callback(f"   Esperado: {output_cue} + {output_bin}")
            if log_callback: log_callback(f"‚ùå Sa√≠da do POPS2CUE: {' | '.join(output_lines)}")
            return False
    except Exception as e:
        if log_callback: log_callback(f"‚ùå Erro inesperado: {str(e)}")
        return False

def convert_cue_to_vcd(cue_path, vcd_output, log_callback=None):
    script_root = get_script_root()
    cue2pops_path = os.path.join(script_root, CUE2POPS_EXE)
    if not os.path.exists(cue2pops_path):
        if log_callback: log_callback(f"‚ùå {CUE2POPS_EXE} n√£o encontrado!")
        return False
    bin_path = os.path.splitext(cue_path)[0] + ".bin"
    if not os.path.exists(bin_path):
        if log_callback: log_callback(f"‚ùå Arquivo BIN n√£o encontrado: {bin_path}")
        return False
    comando = [cue2pops_path, cue_path, vcd_output]
    try:
        if log_callback: log_callback(f"‚ñ∂Ô∏è Convertendo {os.path.basename(cue_path)} ‚Üí VCD...")
        result = subprocess.run(comando, capture_output=True, text=True, encoding='utf-8', errors='replace')
        if result.returncode != 0:
            if log_callback: log_callback(f"‚ùå Falha: {result.stderr}")
            return False
        if log_callback: log_callback(f"‚úÖ VCD criado: {os.path.basename(vcd_output)}")
        return True
    except Exception as e:
        if log_callback: log_callback(f"‚ùå Erro: {e}")
        return False

# ‚úÖ NOVAS FUN√á√ïES PARA CONVERS√ÉO COM CHDMAN
def convert_to_chd(input_path, output_chd, log_callback=None):
    script_root = get_script_root()
    chdman_path = os.path.join(script_root, CHDMAN_EXE)
    if not os.path.exists(chdman_path):
        if log_callback: log_callback(f"‚ùå {CHDMAN_EXE} n√£o encontrado!")
        return False
    ext = os.path.splitext(input_path)[1].lower()
    cue_path = None
    if ext == ".iso":
        cue_path = os.path.splitext(input_path)[0] + ".cue"
        if not os.path.exists(cue_path):
            try:
                with open(cue_path, "w", encoding="utf-8") as f:
                    f.write(f'FILE "{os.path.basename(input_path)}" BINARY\n')
                    f.write("  TRACK 01 MODE2/2352\n")
                    f.write("    INDEX 01 00:00:00\n")
                if log_callback: log_callback(f"üìù CUE tempor√°rio criado: {cue_path}")
            except Exception as e:
                if log_callback: log_callback(f"‚ùå Erro ao criar CUE: {e}")
                return False
    elif ext == ".cue":
        cue_path = input_path
    else:
        if log_callback: log_callback(f"‚ùå Formato n√£o suportado para convers√£o: {ext}")
        return False
    comando = [chdman_path, "createcd", "-i", cue_path, "-o", output_chd]
    try:
        if log_callback: log_callback(f"‚ñ∂Ô∏è Convertendo {os.path.basename(cue_path)} ‚Üí {os.path.basename(output_chd)}...")
        result = subprocess.run(comando, capture_output=True, text=True, encoding='utf-8', errors='replace')
        if result.returncode != 0:
            if log_callback: log_callback(f"‚ùå Falha: {result.stderr}")
            return False
        if log_callback: log_callback(f"‚úÖ CHD criado: {os.path.basename(output_chd)}")
        return True
    except Exception as e:
        if log_callback: log_callback(f"‚ùå Erro: {e}")
        return False

def convert_chd_to_gdi(chd_path, output_gdi, log_callback=None):
    script_root = get_script_root()
    chdman_path = os.path.join(script_root, CHDMAN_EXE)
    if not os.path.exists(chdman_path):
        if log_callback: log_callback(f"‚ùå {CHDMAN_EXE} n√£o encontrado!")
        return False
    comando = [chdman_path, "extractcd", "-i", chd_path, "-o", output_gdi]
    try:
        if log_callback: log_callback(f"‚ñ∂Ô∏è Convertendo {os.path.basename(chd_path)} ‚Üí GDI...")
        result = subprocess.run(comando, capture_output=True, text=True, encoding='utf-8', errors='replace')
        if result.returncode != 0:
            if log_callback: log_callback(f"‚ùå Falha: {result.stderr}")
            return False
        if log_callback: log_callback(f"‚úÖ GDI criado: {os.path.basename(output_gdi)}")
        return True
    except Exception as e:
        if log_callback: log_callback(f"‚ùå Erro: {e}")
        return False

# ‚úÖ ‚úÖ ‚úÖ CORRE√á√ÉO CR√çTICA: CHD ‚Üí ISO DIRETO (SEM CUE TEMPOR√ÅRIA)
def convert_chd_to_iso_only(chd_path, output_iso, log_callback=None):
    script_root = get_script_root()
    chdman_path = os.path.join(script_root, CHDMAN_EXE)
    if not os.path.exists(chdman_path):
        if log_callback: log_callback(f"‚ùå {CHDMAN_EXE} n√£o encontrado!")
        return False
    base_name = os.path.splitext(output_iso)[0]
    chd_dir = os.path.dirname(chd_path)
    temp_cue = os.path.join(chd_dir, f"{base_name}.cue")
    temp_bin = os.path.join(chd_dir, f"{base_name}.bin")
    comando = [chdman_path, "extractcd", "-i", chd_path, "-o", temp_cue, "-ob", temp_bin]
    try:
        if log_callback: 
            log_callback(f"‚ñ∂Ô∏è  Convertendo {os.path.basename(chd_path)} ‚Üí ISO...")
        result = subprocess.run(
            comando,
            capture_output=True,
            text=True,
            encoding='utf-8',
            errors='replace'
        )
        if result.returncode != 0:
            if log_callback:
                log_callback(f"‚ùå Falha na extra√ß√£o: {result.stderr.strip()}")
            return False
        if not os.path.exists(temp_bin) or os.path.getsize(temp_bin) == 0:
            if log_callback:
                log_callback(f"‚ùå Arquivo BIN n√£o gerado ou vazio: {temp_bin}")
            return False
        size_mb = os.path.getsize(temp_bin) / (1024 * 1024)
        if log_callback:
            log_callback(f"   ‚úÖ Extra√≠do: {os.path.basename(temp_bin)} ({size_mb:.1f} MB)")
        if log_callback: 
            log_callback(f"   üîÑ Renomeando {os.path.basename(temp_bin)} ‚Üí {os.path.basename(output_iso)}...")
        shutil.move(temp_bin, output_iso)
        if os.path.exists(temp_cue):
            os.remove(temp_cue)
            if log_callback: 
                log_callback(f"   üóëÔ∏è  Limpeza conclu√≠da: {os.path.basename(temp_cue)} removido")
        if log_callback: 
            log_callback(f"üéâ ISO criado com sucesso: {os.path.basename(output_iso)}")
        return True
    except Exception as e:
        if log_callback: 
            log_callback(f"‚ùå Erro inesperado: {e}")
        try:
            if os.path.exists(temp_cue): os.remove(temp_cue)
            if os.path.exists(temp_bin): os.remove(temp_bin)
        except:
            pass
        return False

# ‚úÖ ‚úÖ ‚úÖ NOVAS FUN√á√ïES: ISO ‚Üî ZSO COM AMBIENTE ISOLADO E LIMPEZA AUTOM√ÅTICA
def convert_iso_to_zso(iso_path, output_zso, log_callback=None):
    script_root = get_script_root()
    ziso_exe = os.path.join(script_root, ZISO_EXE)
    if not os.path.exists(ziso_exe):
        if log_callback: log_callback(f"‚ùå {ZISO_EXE} n√£o encontrado na pasta do script.")
        return False
    if not os.path.exists(iso_path):
        if log_callback: log_callback(f"‚ùå Arquivo ISO n√£o encontrado: {iso_path}")
        return False
    ensure_dir(os.path.dirname(output_zso))
    iso_dir = os.path.dirname(iso_path)
    iso_filename = os.path.basename(iso_path)
    iso_name_no_ext = os.path.splitext(iso_filename)[0]
    iso_temp_dir = os.path.join(iso_dir, "ISO")
    zso_temp_dir = os.path.join(iso_dir, "ZSO")
    ensure_dir(iso_temp_dir)
    ensure_dir(zso_temp_dir)
    temp_iso_path = os.path.join(iso_temp_dir, iso_filename)
    temp_ziso_exe = os.path.join(iso_temp_dir, ZISO_EXE)
    temp_zso_path = os.path.join(zso_temp_dir, f"{iso_name_no_ext}.zso")
    try:
        if log_callback: log_callback(f"üìÅ Movendo ISO para ambiente tempor√°rio: {iso_filename}")
        shutil.move(iso_path, temp_iso_path)
        if log_callback: log_callback(f"üîß Copiando {ZISO_EXE} para ambiente tempor√°rio...")
        shutil.copy2(ziso_exe, temp_ziso_exe)
        if log_callback: log_callback(f"‚ñ∂Ô∏è Convertendo {iso_filename} ‚Üí {iso_name_no_ext}.zso (ambiente isolado)...")
        comando = [temp_ziso_exe, "-c9", temp_iso_path, temp_zso_path]
        result = subprocess.run(
            comando,
            capture_output=True,
            text=True,
            encoding='utf-8',
            errors='replace',
            cwd=iso_temp_dir
        )
        if result.returncode != 0:
            if log_callback: log_callback(f"‚ùå Falha na convers√£o ISO ‚Üí ZSO: {result.stderr.strip()}")
            return False
        if not os.path.exists(temp_zso_path):
            if log_callback: log_callback(f"‚ùå Arquivo ZSO n√£o foi gerado ap√≥s convers√£o!")
            return False
        if log_callback: log_callback(f"üì§ Movendo ZSO resultante para destino final: {os.path.basename(output_zso)}")
        shutil.move(temp_zso_path, output_zso)
        if log_callback: log_callback(f"üîÑ Restaurando ISO original para local: {iso_path}")
        shutil.move(temp_iso_path, iso_path)
        if log_callback: log_callback(f"üßπ Limpando ambiente tempor√°rio...")
        if os.path.exists(temp_ziso_exe): os.remove(temp_ziso_exe)
        if os.path.exists(iso_temp_dir) and len(os.listdir(iso_temp_dir)) == 0: os.rmdir(iso_temp_dir)
        if os.path.exists(zso_temp_dir) and len(os.listdir(zso_temp_dir)) == 0: os.rmdir(zso_temp_dir)
        if log_callback: log_callback(f"‚úÖ Convers√£o ISO ‚Üí ZSO conclu√≠da com sucesso!")
        return True
    except Exception as e:
        if log_callback: log_callback(f"‚ùå Erro durante convers√£o ISO ‚Üí ZSO: {e}")
        try:
            if os.path.exists(temp_iso_path) and not os.path.exists(iso_path):
                shutil.move(temp_iso_path, iso_path)
        except:
            pass
        try:
            if 'temp_ziso_exe' in locals() and os.path.exists(temp_ziso_exe): os.remove(temp_ziso_exe)
            if os.path.exists(iso_temp_dir): shutil.rmtree(iso_temp_dir, ignore_errors=True)
            if os.path.exists(zso_temp_dir): shutil.rmtree(zso_temp_dir, ignore_errors=True)
        except:
            pass
        return False

def convert_zso_to_iso(zso_path, output_iso, log_callback=None):
    script_root = get_script_root()
    ziso_exe = os.path.join(script_root, ZISO_EXE)
    if not os.path.exists(ziso_exe):
        if log_callback: log_callback(f"‚ùå {ZISO_EXE} n√£o encontrado na pasta do script.")
        return False
    if not os.path.exists(zso_path):
        if log_callback: log_callback(f"‚ùå Arquivo ZSO n√£o encontrado: {zso_path}")
        return False
    ensure_dir(os.path.dirname(output_iso))
    zso_dir = os.path.dirname(zso_path)
    zso_filename = os.path.basename(zso_path)
    zso_name_no_ext = os.path.splitext(zso_filename)[0]
    zso_temp_dir = os.path.join(zso_dir, "ZSO")
    iso_temp_dir = os.path.join(zso_dir, "ISO")
    ensure_dir(zso_temp_dir)
    ensure_dir(iso_temp_dir)
    temp_zso_path = os.path.join(zso_temp_dir, zso_filename)
    temp_ziso_exe = os.path.join(zso_temp_dir, ZISO_EXE)
    temp_iso_path = os.path.join(iso_temp_dir, f"{zso_name_no_ext}.iso")
    try:
        if log_callback: log_callback(f"üìÅ Movendo ZSO para ambiente tempor√°rio: {zso_filename}")
        shutil.move(zso_path, temp_zso_path)
        if log_callback: log_callback(f"üîß Copiando {ZISO_EXE} para ambiente tempor√°rio...")
        shutil.copy2(ziso_exe, temp_ziso_exe)
        if log_callback: log_callback(f"‚ñ∂Ô∏è Convertendo {zso_filename} ‚Üí {zso_name_no_ext}.iso (ambiente isolado)...")
        comando = [temp_ziso_exe, "-c", "0", temp_zso_path, temp_iso_path]
        result = subprocess.run(
            comando,
            capture_output=True,
            text=True,
            encoding='utf-8',
            errors='replace',
            cwd=zso_temp_dir
        )
        if result.returncode != 0:
            if log_callback: log_callback(f"‚ùå Falha na convers√£o ZSO ‚Üí ISO: {result.stderr.strip()}")
            return False
        if not os.path.exists(temp_iso_path):
            if log_callback: log_callback(f"‚ùå Arquivo ISO n√£o foi gerado ap√≥s convers√£o!")
            return False
        if log_callback: log_callback(f"üì§ Movendo ISO resultante para destino final: {os.path.basename(output_iso)}")
        shutil.move(temp_iso_path, output_iso)
        if log_callback: log_callback(f"üîÑ Restaurando ZSO original para local: {zso_path}")
        shutil.move(temp_zso_path, zso_path)
        if log_callback: log_callback(f"üßπ Limpando ambiente tempor√°rio...")
        if os.path.exists(temp_ziso_exe): os.remove(temp_ziso_exe)
        if os.path.exists(zso_temp_dir) and len(os.listdir(zso_temp_dir)) == 0: os.rmdir(zso_temp_dir)
        if os.path.exists(iso_temp_dir) and len(os.listdir(iso_temp_dir)) == 0: os.rmdir(iso_temp_dir)
        if log_callback: log_callback(f"‚úÖ Convers√£o ZSO ‚Üí ISO conclu√≠da com sucesso!")
        return True
    except Exception as e:
        if log_callback: log_callback(f"‚ùå Erro durante convers√£o ZSO ‚Üí ISO: {e}")
        try:
            if os.path.exists(temp_zso_path) and not os.path.exists(zso_path):
                shutil.move(temp_zso_path, zso_path)
        except:
            pass
        try:
            if 'temp_ziso_exe' in locals() and os.path.exists(temp_ziso_exe): os.remove(temp_ziso_exe)
            if os.path.exists(zso_temp_dir): shutil.rmtree(zso_temp_dir, ignore_errors=True)
            if os.path.exists(iso_temp_dir): shutil.rmtree(iso_temp_dir, ignore_errors=True)
        except:
            pass
        return False

# ---------------- Fun√ß√µes de Backup e Configura√ß√£o ----------------
def backup_conf_file(target_dir):
    conf_file = os.path.join(target_dir, "conf_apps.cfg")
    if not os.path.exists(conf_file):
        return
    backup_dir = os.path.join(target_dir, "backup")
    ensure_dir(backup_dir)
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_name = f"conf_apps_{timestamp}.bak"
    shutil.copy2(conf_file, os.path.join(backup_dir, backup_name))

def update_conf_apps(game_key, target_dir, elf_name):
    backup_conf_file(target_dir)
    conf_file = os.path.join(target_dir, "conf_apps.cfg")
    entry = f"{game_key}=mass:/{elf_name}\n"
    lines = []
    if os.path.exists(conf_file):
        with open(conf_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    updated = False
    new_lines = []
    for line in lines:
        if line.startswith(game_key + "="):
            new_lines.append(entry)
            updated = True
        else:
            new_lines.append(line)
    if not updated:
        new_lines.append(entry)
    with open(conf_file, 'w', encoding='utf-8') as f:
        f.writelines(new_lines)

def save_cover(elf_name_no_ext, art_dir, cover_path):
    ensure_dir(art_dir)
    ext = os.path.splitext(cover_path)[1]
    dest_path = os.path.join(art_dir, f"XX.{elf_name_no_ext}.ELF_COV{ext}")
    shutil.copy2(cover_path, dest_path)
    return dest_path

def save_logo(elf_name_no_ext, art_dir, logo_path):
    ensure_dir(art_dir)
    ext = os.path.splitext(logo_path)[1]
    dest_path = os.path.join(art_dir, f"XX.{elf_name_no_ext}.ELF_LGO{ext}")
    shutil.copy2(logo_path, dest_path)
    return dest_path

def get_elf_name_from_game_key(game_key, target_dir):
    conf_file = os.path.join(target_dir, "conf_apps.cfg")
    if not os.path.exists(conf_file):
        return None
    with open(conf_file, 'r', encoding='utf-8') as f:
        for line in f:
            if line.startswith(game_key + "="):
                elf_path = line.split("=", 1)[1].strip()
                elf_name = os.path.basename(elf_path.replace("mass:/", ""))
                if elf_name.startswith("XX."):
                    return elf_name[3:-4]
                else:
                    return os.path.splitext(elf_name)[0]
    return None

# [NOVO] - Fun√ß√£o auxiliar para buscar e copiar descri√ß√£o .cfg
def copy_description_cfg(game_code, script_root, target_dir, log_callback=None):
    """
    Procura por um arquivo .cfg com nome igual ao game_code dentro da pasta _description_psx.
    Aceita tanto '[SLUS_008.24]' quanto 'SLUS_008.24'.
    Cria a pasta 'CFG' na RAIZ do target_dir (ex: K:/CFG/) se n√£o existir.
    COPIA o arquivo .cfg para l√° (N√ÉO MOVE ‚Äî mant√©m o original em _description_psx).
    Retorna True se encontrou e copiou, False caso contr√°rio.
    """
    desc_dir = os.path.join(script_root, "_description_psx")
    
    # Verifica se a pasta _description_psx existe
    if not os.path.exists(desc_dir):
        if log_callback:
            log_callback(f"‚ùå Pasta '_description_psx' N√ÉO ENCONTRADA em: {desc_dir}")
        return False

    # Normaliza o c√≥digo do jogo: remove colchetes se houver
    clean_code = game_code.strip()
    if clean_code.startswith('[') and clean_code.endswith(']'):
        clean_code = clean_code[1:-1].strip()

    # Nome esperado do arquivo .cfg
    cfg_filename = f"{clean_code}.cfg"
    cfg_path = os.path.join(desc_dir, cfg_filename)

    # Verifica se o arquivo .cfg existe
    if not os.path.isfile(cfg_path):
        if log_callback:
            log_callback(f"‚ÑπÔ∏è Arquivo '{cfg_filename}' n√£o encontrado em '_description_psx'.")
        return False

    # ‚úÖ PASSO CR√çTICO: Define a pasta CFG na RAIZ do diret√≥rio de sa√≠da
    cfg_target_dir = os.path.join(target_dir, "CFG")  # ‚Üê ISSO √â K:/CFG!
    ensure_dir(cfg_target_dir)  # ‚úÖ CRIA SE N√ÉO EXISTIR

    if log_callback:
        log_callback(f"‚úÖ Pasta 'CFG' criada/verificada em: {cfg_target_dir}")

    dest_path = os.path.join(cfg_target_dir, cfg_filename)

    # Verifica se j√° existe no destino (compara√ß√£o de conte√∫do)
    if os.path.exists(dest_path):
        if os.path.getsize(cfg_path) == os.path.getsize(dest_path):
            with open(cfg_path, 'rb') as f1, open(dest_path, 'rb') as f2:
                if f1.read() == f2.read():
                    if log_callback:
                        log_callback(f"‚úÖ Descri√ß√£o j√° existe e √© id√™ntica: {cfg_filename}")
                    return True
        try:
            os.remove(dest_path)
            if log_callback:
                log_callback(f"‚ö†Ô∏è Sobrescrevendo arquivo existente: {cfg_filename}")
        except Exception as e:
            if log_callback:
                log_callback(f"‚ùå Falha ao sobrescrever {cfg_filename}: {e}")
            return False

    # ‚úÖ COPIA o arquivo (N√ÉO MOVE!) ‚Äî O ORIGINAL PERMANECE EM _description_psx/
    try:
        shutil.copy2(cfg_path, dest_path)
        if log_callback:
            log_callback(f"üìÑ DESCRICAO COPIADA COM SUCESSO: {cfg_filename} ‚Üí {dest_path}")
        return True

    except PermissionError:
        if log_callback:
            log_callback(f"‚ùå Permiss√£o negada ao copiar {cfg_filename}. Verifique permiss√µes da pasta.")
        return False
    except FileNotFoundError:
        if log_callback:
            log_callback(f"‚ùå Arquivo fonte n√£o encontrado ap√≥s valida√ß√£o: {cfg_path}")
        return False
    except Exception as e:
        if log_callback:
            log_callback(f"‚ùå Erro inesperado ao copiar {cfg_filename}: {e}")
        return False


# ‚úÖ ‚úÖ ‚úÖ FUN√á√ÉO PRINCIPAL REVISADA: process_game com suporte perfeito a .cue/.bin + DESCRI√á√ïES
def process_game(file_path, pops_dir, target_dir, cover_path=None, logo_path=None, log_callback=None, progress_callback=None):
    original_name = os.path.basename(file_path)
    game_name, ext = os.path.splitext(original_name)
    ext = ext.lower()
    match = re.search(r"\[(.*?)\]", game_name)
    code_in_brackets = match.group(1) if match else None
    base_name = code_in_brackets if code_in_brackets else game_name
    elf_name = f"XX.{base_name}.ELF"
    elf_name_no_ext = base_name
    vcd_name = f"{code_in_brackets}.VCD" if code_in_brackets else f"{game_name}.VCD"
    save_folder_name = elf_name_no_ext
    conf_name = re.sub(r"\[.*?\]", "", game_name).strip()
    temp_dir = None

    if ext == ".chd":
        cue_path, bin_path, temp_dir = convert_chd_to_iso_temp(file_path, log_callback, progress_callback)
        if not cue_path or not bin_path:
            return False
        script_root = get_script_root()
        cue2pops_path = os.path.join(script_root, CUE2POPS_EXE)
        if not os.path.exists(cue2pops_path):
            if log_callback: log_callback(f"‚ùå {CUE2POPS_EXE} n√£o encontrado!")
            if temp_dir: shutil.rmtree(temp_dir, ignore_errors=True)
            return False
        vcd_output = os.path.join(pops_dir, vcd_name)
        comando_cue2pops = [cue2pops_path, cue_path, vcd_output]
        try:
            if log_callback: log_callback(f"‚ñ∂Ô∏è Convertendo {os.path.basename(cue_path)} para VCD...")
            subprocess.run(comando_cue2pops, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
            if log_callback: log_callback(f"‚úÖ VCD criado: {os.path.basename(vcd_output)}")
        except Exception as e:
            if log_callback: log_callback(f"‚ùå Falha ao converter CUE para VCD: {e}")
            if temp_dir: shutil.rmtree(temp_dir, ignore_errors=True)
            return False
        file_path = None
    elif ext == ".cue":
        bin_path = os.path.splitext(file_path)[0] + ".bin"
        if not os.path.exists(bin_path):
            if log_callback: log_callback(f"‚ùå Arquivo BIN associado n√£o encontrado: {bin_path}")
            return False
        script_root = get_script_root()
        cue2pops_path = os.path.join(script_root, CUE2POPS_EXE)
        if not os.path.exists(cue2pops_path):
            if log_callback: log_callback(f"‚ùå {CUE2POPS_EXE} n√£o encontrado!")
            return False
        vcd_output = os.path.join(pops_dir, vcd_name)
        if log_callback: log_callback(f"‚ñ∂Ô∏è Convertendo {os.path.basename(file_path)} + {os.path.basename(bin_path)} para VCD...")
        if not convert_cue_to_vcd(file_path, vcd_output, log_callback):
            return False
    elif ext == ".bin":
        cue_path = os.path.splitext(file_path)[0] + ".cue"
        if not os.path.exists(cue_path):
            if log_callback: log_callback(f"‚ùå Arquivo CUE associado n√£o encontrado: {cue_path}")
            return False
        script_root = get_script_root()
        cue2pops_path = os.path.join(script_root, CUE2POPS_EXE)
        if not os.path.exists(cue2pops_path):
            if log_callback: log_callback(f"‚ùå {CUE2POPS_EXE} n√£o encontrado!")
            return False
        vcd_output = os.path.join(pops_dir, vcd_name)
        if log_callback: log_callback(f"‚ñ∂Ô∏è Convertendo {os.path.basename(cue_path)} + {os.path.basename(file_path)} para VCD...")
        if not convert_cue_to_vcd(cue_path, vcd_output, log_callback):
            return False
    else:
        vcd_path = os.path.join(pops_dir, vcd_name)
        if log_callback: log_callback(f"üì¶ Copiando arquivo original ({ext}) como VCD...")
        convert_to_vcd(file_path, vcd_path, log_callback)

    save_folder = os.path.join(pops_dir, save_folder_name)
    ensure_dir(save_folder)
    copy_file(SLOT0_VMC_NAME, os.path.join(save_folder, SLOT0_VMC_NAME))
    copy_file(SLOT1_VMC_NAME, os.path.join(save_folder, SLOT1_VMC_NAME))

    script_root = get_script_root()

    # [MUDAN√áA] - Aplicar fix de _pops_fix (j√° existente)
    fix_src = os.path.join(script_root, "_pops_fix", elf_name_no_ext)
    if os.path.exists(fix_src):
        if log_callback: log_callback(f"üîß Aplicando fix para {elf_name_no_ext}...")
        copy_tree(fix_src, save_folder, log_callback)

    # [NOVO] - Aplicar descri√ß√£o .cfg de _description_psx
    # Usa o mesmo base_name (c√≥digo do jogo) para procurar SLUS_XXX.XX.cfg
        # [CORRE√á√ÉO FINAL] - Copia .cfg para a RAIZ da pasta de sa√≠da (mesmo n√≠vel da pasta POPS)
    if code_in_brackets:
        copy_description_cfg(code_in_brackets, script_root, target_dir, log_callback)
    else:
        copy_description_cfg(base_name, script_root, target_dir, log_callback)

    outside_elf = os.path.join(target_dir, elf_name)
    copy_file(POPS_ELF_NAME, outside_elf)
    update_conf_apps(conf_name, target_dir, elf_name)
    art_dir = os.path.join(target_dir, ART_DIR_NAME)
    if cover_path:
        save_cover(elf_name_no_ext, art_dir, cover_path)
    if logo_path:
        save_logo(elf_name_no_ext, art_dir, logo_path)

    if temp_dir:
        shutil.rmtree(temp_dir, ignore_errors=True)

    return True

# ‚úÖ ‚úÖ ‚úÖ FUN√á√ÉO FINAL: Instala√ß√£o USB com merge inteligente e oculta√ß√£o
def install_usb_files(destination_dir, log_callback=None):
    """
    Copia TODA a estrutura da pasta 'usb_install/' (incluindo subpastas e arquivos)
    para o destino selecionado, e oculta todos os itens no Windows.
    
    Comportamento:
    - Se destino N√ÉO existe ‚Üí cria e copia tudo
    - Se destino EXISTE ‚Üí mescla (merge) o conte√∫do sem apagar o que j√° est√° l√°
    - Arquivos iguais s√£o ignorados (compara√ß√£o por conte√∫do)
    - Pastas s√£o copiadas recursivamente
    - Todos os itens s√£o ocultados no Windows
    """
    script_root = get_script_root()
    usb_install_path = os.path.join(script_root, "usb_install")

    if not os.path.exists(usb_install_path):
        if log_callback: log_callback("‚ùå Pasta 'usb_install' n√£o encontrada na raiz do script!", "error")
        return False

    items = os.listdir(usb_install_path)
    if not items:
        if log_callback: log_callback("‚ö†Ô∏è Pasta 'usb_install' est√° vazia. Nada para copiar.", "warning")
        return False

    total_items = len(items)
    if log_callback: log_callback(f"üöÄ Iniciando instala√ß√£o USB... ({total_items} itens)", "info")

    success_count = 0
    failed_count = 0
    skipped_count = 0

    for item in items:
        src = os.path.join(usb_install_path, item)
        dst = os.path.join(destination_dir, item)

        try:
            if os.path.isdir(src):
                # ‚úÖ PASTA: Mescla recursivamente
                if os.path.exists(dst):
                    if log_callback: log_callback(f"üìÅ Mesclando pasta: {item}", "info")
                    copy_tree(src, dst, lambda msg: log_callback(msg, "info"))
                else:
                    shutil.copytree(src, dst)
                    if log_callback: log_callback(f"üìÅ Copiado diret√≥rio: {item}", "success")
            else:
                # ‚úÖ ARQUIVO: Verifica se j√° existe e √© igual
                if os.path.exists(dst):
                    if os.path.getsize(src) == os.path.getsize(dst):
                        with open(src, 'rb') as f1, open(dst, 'rb') as f2:
                            if f1.read() == f2.read():
                                if log_callback: log_callback(f"‚úÖ Ignorado (igual): {item}", "info")
                                skipped_count += 1
                                continue
                    # Se diferente, sobrescreve
                    shutil.copy2(src, dst)
                    if log_callback: log_callback(f"üìÑ Atualizado: {item}", "success")
                else:
                    shutil.copy2(src, dst)
                    if log_callback: log_callback(f"üìÑ Copiado: {item}", "success")

            # ‚úÖ OCULTAR ITEM NO WINDOWS (arquivo OU pasta)
            if sys.platform == "win32":
                import ctypes
                FILE_ATTRIBUTE_HIDDEN = 0x02
                ctypes.windll.kernel32.SetFileAttributesW(dst, FILE_ATTRIBUTE_HIDDEN)
                if log_callback: log_callback(f"üëÅÔ∏è  Ocultado: {item}", "info")

            success_count += 1

        except Exception as e:
            failed_count += 1
            if log_callback: log_callback(f"‚ùå Falha ao copiar '{item}': {str(e)}", "error")

    # ‚úÖ FINALIZA√á√ÉO
    if log_callback:
        log_callback(f"\nüéâ INSTALA√á√ÉO CONCLU√çDA!\n"
                     f"   ‚úîÔ∏è Sucesso: {success_count}\n"
                     f"   ‚ö†Ô∏è Ignorados (iguais): {skipped_count}\n"
                     f"   ‚ùå Falhas: {failed_count}", "success")

    return success_count > 0

```
‚îî‚îÄ‚îÄ popstation_gui.py
```python
import tkinter as tk
import tkinter.font as tkfont
from tkinter import filedialog, messagebox, ttk, simpledialog, colorchooser
from PIL import Image, ImageTk
import webbrowser
import datetime
import winsound
from tkinterdnd2 import TkinterDnD, DND_FILES
from popstation_core import *
import os
import json
import shutil
import zipfile
import requests
import sys

# ---------------- Configura√ß√µes de GUI ----------------
COVER_SIZE = (150, 150)   # Tamanho das capas (aumentado)
LOGO_SIZE = (60, 60)      # Tamanho dos logos
PREVIEW_SIZE = (240, 240) # Tamanho do preview ao passar o mouse
TILE_BG = "#2e2e2e"
BG_COLOR = "#1b1b1b"
TEXT_COLOR = "#e0e0e0"
ACCENT_COLOR = "#4a90e2"
ERROR_COLOR = "#ff555b"
SUCCESS_COLOR = "#50fa7b"
WARNING_COLOR = "#f1fa8c"
CURRENT_VERSION = "4.3"

# ---------------- Tooltip de Imagem ----------------
class ImageTooltip:
    def __init__(self, widget, image_path=None, size=(240, 240)):
        self.widget = widget
        self.image_path = image_path
        self.size = size
        self.tooltip_window = None
        self.widget.bind("<Enter>", self.show_tooltip)
        self.widget.bind("<Leave>", self.hide_tooltip)
    
    def show_tooltip(self, event=None):
        if not self.image_path or not os.path.exists(self.image_path):
            return
        x = self.widget.winfo_rootx() + 20
        y = self.widget.winfo_rooty() + 20
        self.tooltip_window = tk.Toplevel(self.widget)
        self.tooltip_window.wm_overrideredirect(True)
        self.tooltip_window.wm_geometry(f"+{x}+{y}")
        try:
            img = Image.open(self.image_path)
            img.thumbnail(self.size)
            photo = ImageTk.PhotoImage(img)
            label = tk.Label(self.tooltip_window, image=photo, bg="black", bd=2, relief="solid")
            label.image = photo
            label.pack()
        except:
            label = tk.Label(self.tooltip_window, text="Erro ao carregar imagem", bg="red", fg="white", padx=5, pady=5)
            label.pack()
    
    def hide_tooltip(self, event=None):
        if self.tooltip_window:
            self.tooltip_window.destroy()
            self.tooltip_window = None

# ---------------- CONFIGURA√á√ÉO DE IDIOMA ----------------
LANG_DIR = "lang"
DEFAULT_LANG = "pt_BR"

def load_language():
    """Carrega o idioma baseado no sistema ou no arquivo de configura√ß√£o."""
    lang_file = os.path.join(LANG_DIR, f"{DEFAULT_LANG}.json")
    if not os.path.exists(lang_file):
        os.makedirs(LANG_DIR, exist_ok=True)
        # Cria arquivo padr√£o em PT-BR
        default_lang = {
            "btn_select_folder": "Selecionar Pasta",
            "lbl_games_count": "Jogos: {count}",
            "msg_no_folder": "Nenhuma pasta de destino selecionada.\nV√° para a aba 'Convers√£o de Jogos' e escolha uma pasta.",
            "msg_no_conf": "Arquivo 'conf_apps.cfg' n√£o encontrado.\nVoc√™ precisa processar jogos primeiro na aba 'Convers√£o'.",
            "msg_confirm_delete": "Apagar '{game_key}'?",
            "msg_success": "Sucesso",
            "msg_error": "Erro",
            "msg_warning": "Aviso",
            "btn_check_fix": "üîç Verificar e Corrigir",
            "btn_export_zip": "üíæ Compactar e Exportar para USB",
            "chk_ps1_mode": "For√ßar compatibilidade PS1 (Nomes em ISO-8859-1)",
            "btn_test_mode": "üß™ Modo de Teste",
            "btn_check_update": "üîÑ Verificar Atualiza√ß√µes",
            "update_available": "Nova vers√£o v{new_version} dispon√≠vel! Baixar em:\n{url}",
            "update_current": "Voc√™ est√° na vers√£o mais recente!",
            "recent_games": "Jogos Recentes:",
            "btn_clear_recent": "üóëÔ∏è Limpar Hist√≥rico"
        }
        with open(lang_file, "w", encoding="utf-8") as f:
            json.dump(default_lang, f, indent=2, ensure_ascii=False)
    with open(lang_file, "r", encoding="utf-8") as f:
        return json.load(f)

texts = load_language()

# ---------------- CONFIGURA√á√ÉO DE CONFIGURA√á√ÉO ----------------
CONFIG_FILE = "popstation.cfg"

def load_config():
    """Carrega configura√ß√£o do arquivo .popstation.cfg"""
    if not os.path.exists(CONFIG_FILE):
        return {
            "last_folder": "",
            "theme": "dark",
            "view_mode": "grid",
            "language": DEFAULT_LANG,
            "recent_games": [],
            "ps1_mode": False,
            "test_mode": False
        }
    with open(CONFIG_FILE, "r", encoding="utf-8") as f:
        return json.load(f)

def save_config(config):
    """Salva configura√ß√£o no arquivo .popstation.cfg"""
    with open(CONFIG_FILE, "w", encoding="utf-8") as f:
        json.dump(config, f, indent=2, ensure_ascii=False)

config = load_config()

# ---------------- MODOS DE EXECU√á√ÉO ----------------
if len(sys.argv) > 1 and sys.argv[1] == "--batch":
    # Modo silencioso: executa por linha de comando
    if len(sys.argv) >= 4:
        files = sys.argv[2].split(",")
        target_dir = sys.argv[3]
        print(f"[BATCH] Processando {len(files)} arquivos em {target_dir}")
        # Simula processamento sem GUI
        script_root = get_script_root()
        pops_dir = os.path.join(target_dir, POPS_DIR_NAME)
        ensure_dir(pops_dir)
        copy_file(os.path.join(script_root, "BIOS.BIN"), os.path.join(pops_dir, "BIOS.BIN"))
        copy_file(os.path.join(script_root, "POPSTARTER.ELF"), os.path.join(pops_dir, "POPSTARTER.ELF"))
        for f in files:
            game_name = os.path.splitext(os.path.basename(f))[0]
            process_game(f, pops_dir, target_dir, None, None, lambda msg: print(msg), lambda msg, val: None)
        print("[BATCH] Conclu√≠do.")
        sys.exit(0)
    else:
        print("Uso: python script.py --batch \"file1.iso,file2.iso\" \"C:\\destino\"")
        sys.exit(1)

# ---------------- GUI Principal ----------------
class PopsManagerGUI:
    def __init__(self, root):
        self.root = root
        root.title(f"POPStation v{CURRENT_VERSION}")
        root.geometry("1100x750")  # Tamanho fixo padr√£o
        root.configure(bg=BG_COLOR)
        self.current_theme = config.get("theme", "dark")
        self.retro_mode = False
        self.files = []
        self.covers = {}
        self.logos = {}
        self.target_dir = config.get("last_folder", "")
        self.cover_images = {}
        self.game_tiles = {}
        self.bios_files = self.find_bios_files()
        self.advanced_files = []
        self.advanced_output_folder = None
        self.status_var = tk.StringVar(value="Pronto")
        self.status_bar = tk.Label(root, textvariable=self.status_var, bg="#333", fg="#aaa", anchor="w", padx=10)
        self.status_bar.pack(side="bottom", fill="x")

        script_root = get_script_root()
        print(f"[INFO] Pasta raiz do script: {script_root}")

        self.create_menu()
        self.notebook = ttk.Notebook(root)
        self.notebook.pack(fill="both", expand=True, padx=5, pady=5)

        self.tab_convert = ttk.Frame(self.notebook)
        self.tab_manage = ttk.Frame(self.notebook)
        self.tab_advanced = ttk.Frame(self.notebook)
        self.tab_usb_install = ttk.Frame(self.notebook)
        self.tab_console = ttk.Frame(self.notebook)

        self.notebook.add(self.tab_convert, text="üéÆ Convers√£o de Jogos")
        self.notebook.add(self.tab_manage, text="üìÅ Gerenciamento de Jogos")
        self.notebook.add(self.tab_advanced, text="üîÑ Convers√µes Avan√ßadas")
        self.notebook.add(self.tab_usb_install, text="üîå Installs USB")
        self.notebook.add(self.tab_console, text="‚å®Ô∏è Console")

        self.setup_convert_tab()
        self.setup_manage_tab()
        self.setup_advanced_tab()
        self.setup_usb_install_tab()
        self.setup_console_tab()

        root.bind("<Control-Shift-R>", self.toggle_retro_mode)
        self.setup_drag_drop()

        # Carrega tema e modo de exibi√ß√£o da configura√ß√£o
        self.toggle_theme()
        self.view_mode.set(config.get("view_mode", "grid"))

    def create_menu(self):
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        file_menu = tk.Menu(menubar, tearoff=0)
        file_menu.add_command(label=texts["btn_select_folder"], command=self.select_folder)
        file_menu.add_command(label="Abrir Pasta Destino", command=self.open_target_folder)
        file_menu.add_separator()
        file_menu.add_command(label="Alternar Tema", command=self.toggle_theme)
        file_menu.add_separator()
        file_menu.add_command(label="Sair", command=self.root.quit)
        menubar.add_cascade(label="Arquivo", menu=file_menu)

        tools_menu = tk.Menu(menubar, tearoff=0)
        tools_menu.add_command(label="Exportar Lista (CSV)", command=self.export_csv)
        tools_menu.add_command(label="Exportar Lista (HTML)", command=self.export_html)
        tools_menu.add_command(label=texts["btn_check_fix"], command=self.verify_and_fix)
        tools_menu.add_command(label=texts["btn_export_zip"], command=self.export_zip_usb)
        tools_menu.add_command(label="Verificar Integridade", command=self.verify_integrity)
        menubar.add_cascade(label="Ferramentas", menu=tools_menu)

        help_menu = tk.Menu(menubar, tearoff=0)
        help_menu.add_command(label="Tutorial no YouTube", command=lambda: webbrowser.open("https://youtube.com"))
        help_menu.add_command(label="Reportar Bug", command=lambda: webbrowser.open("https://github.com"))
        help_menu.add_command(label=texts["btn_check_update"], command=self.check_for_updates)
        help_menu.add_command(label="Sobre", command=self.show_about)
        menubar.add_cascade(label="Ajuda", menu=help_menu)

    def setup_drag_drop(self):
        self.tab_convert.drop_target_register(DND_FILES)
        self.tab_convert.dnd_bind('<<Drop>>', self.on_drop)

    def on_drop(self, event):
        files = self.root.tk.splitlist(event.data)
        valid_files = [f for f in files if os.path.splitext(f)[1].lower() in SUPPORTED_FORMATS]
        if valid_files:
            self.files.extend(valid_files)
            self.update_file_listbox()
            self.log(f"üì• {len(valid_files)} arquivos adicionados via arrastar e soltar.")

    def setup_convert_tab(self):
        frame_files = ttk.LabelFrame(self.tab_convert, text="1. üìÇ Sele√ß√£o de Jogos")
        frame_files.pack(fill="x", padx=10, pady=5)
        btn_frame = tk.Frame(frame_files)
        btn_frame.pack(side="left", padx=5, pady=5)
        ttk.Button(btn_frame, text=texts["btn_select_folder"], command=self.select_files).pack(pady=2)
        ttk.Button(btn_frame, text="üñºÔ∏è Selecionar Capas", command=self.select_covers).pack(pady=2)
        ttk.Button(btn_frame, text="üîñ Selecionar Logos", command=self.select_logos).pack(pady=2)

        # --- Hist√≥rico de Jogos Recentes ---
        recent_frame = tk.Frame(frame_files, bg=BG_COLOR)
        recent_frame.pack(side="left", padx=10, pady=5, fill="y")
        tk.Label(recent_frame, text=texts["recent_games"], bg=BG_COLOR, fg=TEXT_COLOR, font=("Arial", 9, "bold")).pack(anchor="w", pady=(0, 5))
        self.recent_listbox = tk.Listbox(recent_frame, height=5, width=20, bg="#2b2b2b", fg=TEXT_COLOR, selectmode=tk.SINGLE)
        self.recent_listbox.pack()
        self.recent_listbox.bind("<Double-Button-1>", self.load_recent_game)
        self.update_recent_list()

        ttk.Button(recent_frame, text=texts["btn_clear_recent"], command=self.clear_recent_list).pack(pady=5)

        self.listbox = tk.Listbox(frame_files, width=80, height=10, bg="#2b2b2b", fg=TEXT_COLOR)
        self.listbox.pack(side="left", padx=5, pady=5, fill="both", expand=True)

        frame_bios = ttk.LabelFrame(self.tab_convert, text="2. üñ•Ô∏è BIOS")
        frame_bios.pack(fill="x", padx=10, pady=5)
        self.bios_var = tk.StringVar()
        if self.bios_files:
            self.bios_var.set(self.bios_files[0])
            ttk.Combobox(frame_bios, textvariable=self.bios_var, values=self.bios_files, state="readonly").pack(pady=5)
        else:
            tk.Label(frame_bios, text="Nenhum BIOS.BIN encontrado!", fg="red").pack()

        frame_dest = ttk.LabelFrame(self.tab_convert, text="3. üìÇ Pasta de Destino")
        frame_dest.pack(fill="x", padx=10, pady=5)
        self.dest_label = tk.Label(frame_dest, text=f"üìÅ {self.target_dir}" if self.target_dir else "Nenhuma pasta selecionada", bg=BG_COLOR, fg=TEXT_COLOR)
        self.dest_label.pack(side="left", padx=5, pady=5)
        ttk.Button(frame_dest, text="Selecionar Pasta", command=self.select_folder).pack(side="left", padx=5, pady=5)

        # --- Modo PS1 e Modo de Teste ---
        mode_frame = tk.Frame(frame_dest, bg=BG_COLOR)
        mode_frame.pack(side="left", padx=10, pady=5)
        self.ps1_mode_var = tk.BooleanVar(value=config.get("ps1_mode", False))
        tk.Checkbutton(mode_frame, text=texts["chk_ps1_mode"], variable=self.ps1_mode_var, bg=BG_COLOR, fg=TEXT_COLOR, selectcolor=BG_COLOR).pack(anchor="w")
        self.test_mode_var = tk.BooleanVar(value=config.get("test_mode", False))
        tk.Checkbutton(mode_frame, text=texts["btn_test_mode"], variable=self.test_mode_var, bg=BG_COLOR, fg=TEXT_COLOR, selectcolor=BG_COLOR).pack(anchor="w")

        self.progress = ttk.Progressbar(self.tab_convert, orient="horizontal", length=800, mode="determinate")
        self.progress.pack(pady=10)
        self.progress_label = tk.Label(self.tab_convert, text="", bg=BG_COLOR, fg="#00ff00")
        self.progress_label.pack()

        frame_actions = ttk.LabelFrame(self.tab_convert, text="4. ‚ö° A√ß√µes")
        frame_actions.pack(fill="x", padx=10, pady=5)
        ttk.Button(frame_actions, text="‚ñ∂Ô∏è Processar Jogos", command=self.process_games).pack(side="left", padx=5, pady=5)

        self.log_text = tk.Text(frame_actions, height=8, width=80, bg="#1b1b1b", fg=TEXT_COLOR)
        self.log_text.pack(side="left", padx=5, pady=5, fill="both", expand=True)
        self.log_text.tag_config("error", foreground=ERROR_COLOR)
        self.log_text.tag_config("success", foreground=SUCCESS_COLOR)
        self.log_text.tag_config("warning", foreground=WARNING_COLOR)

    def setup_manage_tab(self):
        # --- Frame superior: Contagem e uso de disco ---
        top_frame = tk.Frame(self.tab_manage, bg=BG_COLOR)
        top_frame.pack(fill="x", padx=5, pady=5)
        # Contagem de jogos
        self.games_count_label = tk.Label(
            top_frame,
            text=texts["lbl_games_count"].format(count="0"),
            bg=BG_COLOR,
            fg=TEXT_COLOR,
            font=("Arial", 10, "bold")
        )
        self.games_count_label.pack(side="left", padx=10)
        # Uso de disco
        self.disk_usage_label = tk.Label(
            top_frame,
            text="üíæ Uso: -- / -- (---% livre)",
            bg=BG_COLOR,
            fg=TEXT_COLOR,
            font=("Arial", 9)
        )
        self.disk_usage_label.pack(side="right", padx=10)

        # --- Barra de pesquisa + modo de exibi√ß√£o ---
        search_and_view_frame = tk.Frame(self.tab_manage, bg=BG_COLOR)
        search_and_view_frame.pack(fill="x", padx=5, pady=5)
        tk.Label(search_and_view_frame, text="üîç Pesquisar:", bg=BG_COLOR, fg=TEXT_COLOR).pack(side="left", padx=5)
        self.search_var = tk.StringVar()
        self.search_var.trace("w", lambda *args: self.refresh_manage_tab())  # Atualiza em tempo real
        tk.Entry(search_and_view_frame, textvariable=self.search_var, width=40).pack(side="left", padx=5, fill="x", expand=True)

        # Bot√µes de modo de exibi√ß√£o
        view_frame = tk.Frame(search_and_view_frame, bg=BG_COLOR)
        view_frame.pack(side="right", padx=10)
        self.view_mode = tk.StringVar(value=config.get("view_mode", "grid"))  # grid | list | cards
        ttk.Radiobutton(view_frame, text="Grid", variable=self.view_mode, value="grid", command=self.refresh_manage_tab).pack(side="left", padx=2)
        ttk.Radiobutton(view_frame, text="Lista", variable=self.view_mode, value="list", command=self.refresh_manage_tab).pack(side="left", padx=2)
        ttk.Radiobutton(view_frame, text="Cards", variable=self.view_mode, value="cards", command=self.refresh_manage_tab).pack(side="left", padx=2)

        # Bot√µes de exporta√ß√£o e abertura
        ttk.Button(search_and_view_frame, text="üìä Exportar CSV", command=self.export_csv).pack(side="right", padx=5)
        ttk.Button(search_and_view_frame, text="üìÇ Abrir Pasta", command=self.open_target_folder).pack(side="right", padx=5)

        # --- Canvas com scroll para os jogos ---
        self.canvas = tk.Canvas(self.tab_manage, bg=BG_COLOR, highlightthickness=0)
        self.scrollbar = tk.Scrollbar(self.tab_manage, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = tk.Frame(self.canvas, bg=BG_COLOR)
        self.scrollable_frame.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        self.canvas.pack(side="left", fill="both", expand=True, padx=5)
        self.scrollbar.pack(side="right", fill="y")

        # Inicializa a interface
        self.refresh_manage_tab()

    def setup_advanced_tab(self):
        frame = ttk.Frame(self.tab_advanced)
        frame.pack(fill="both", expand=True, padx=10, pady=10)
        tk.Label(frame, text="üîÑ Convers√µes Avan√ßadas", font=("Arial", 12, "bold")).pack(pady=5)

        # --- Arquivo de origem ---
        file_frame = ttk.LabelFrame(frame, text="1. Selecione o arquivo de origem")
        file_frame.pack(fill="x", pady=5)
        self.advanced_file_label = tk.Label(file_frame, text="Nenhum arquivo selecionado", bg=BG_COLOR, fg=TEXT_COLOR)
        self.advanced_file_label.pack(side="left", padx=5, pady=5)
        ttk.Button(file_frame, text="Selecionar Arquivo", command=self.select_advanced_file).pack(side="left", padx=5, pady=5)

        # --- Formato de sa√≠da ---
        format_frame = ttk.LabelFrame(frame, text="2. Escolha o formato de sa√≠da")
        format_frame.pack(fill="x", pady=5)
        self.output_format = tk.StringVar(value="cue_bin")
        formats = [
            ("CUE + BIN", "cue_bin"),
            ("ISO", "iso"),
            ("ZSO", "zso"),
            ("GDI", "gdi"),
            ("CHD", "chd"),
            ("VCD", "vcd"),
        ]
        for text, value in formats:
            ttk.Radiobutton(format_frame, text=text, variable=self.output_format, value=value).pack(anchor="w", padx=20)

        # --- Pasta de sa√≠da ---
        output_frame = ttk.LabelFrame(frame, text="3. Pasta de Sa√≠da")
        output_frame.pack(fill="x", pady=5)
        self.advanced_output_label = tk.Label(output_frame, text="Nenhuma pasta selecionada", bg=BG_COLOR, fg=TEXT_COLOR)
        self.advanced_output_label.pack(side="left", padx=5, pady=5)
        ttk.Button(output_frame, text="Selecionar Pasta", command=self.select_advanced_output).pack(side="left", padx=5, pady=5)

        # --- Bot√£o de iniciar ---
        ttk.Button(frame, text="‚ñ∂Ô∏è Iniciar Convers√£o", command=self.start_advanced_conversion).pack(pady=10)

        # --- Log ---
        self.advanced_log_text = tk.Text(frame, height=10, bg="#1b1b1b", fg=TEXT_COLOR)
        self.advanced_log_text.pack(fill="both", expand=True, pady=5)
        self.advanced_log_text.tag_config("error", foreground=ERROR_COLOR)
        self.advanced_log_text.tag_config("success", foreground=SUCCESS_COLOR)

    def setup_usb_install_tab(self):
        frame = ttk.Frame(self.tab_usb_install)
        frame.pack(fill="both", expand=True, padx=10, pady=10)
        tk.Label(frame, text="üîå Installs USB", font=("Arial", 14, "bold"), bg=BG_COLOR, fg=ACCENT_COLOR).pack(pady=10)
        desc = tk.Label(
            frame,
            text="Copie toda a estrutura da pasta 'usb_install' para seu dispositivo USB.\nTodos os arquivos e pastas ser√£o copiados e ocultados automaticamente.",
            bg=BG_COLOR, fg=TEXT_COLOR, wraplength=900, justify="center"
        )
        desc.pack(pady=5)
        dest_frame = ttk.LabelFrame(frame, text="üìÇ Selecione o diret√≥rio de destino (USB)")
        dest_frame.pack(fill="x", pady=10, padx=20)
        self.usb_dest_label = tk.Label(dest_frame, text="Nenhum destino selecionado", bg=BG_COLOR, fg=TEXT_COLOR, anchor="w")
        self.usb_dest_label.pack(side="left", padx=10, pady=10, fill="x", expand=True)
        ttk.Button(dest_frame, text="üìÅ Selecionar Pasta", command=self.select_usb_destination).pack(side="right", padx=10, pady=10)
        origin_frame = ttk.LabelFrame(frame, text="üì¶ Origem (autom√°tica)")
        origin_frame.pack(fill="x", pady=10, padx=20)
        script_root = get_script_root()
        usb_install_path = os.path.join(script_root, "usb_install")
        self.usb_origin_label = tk.Label(
            origin_frame,
            text=f"üìÇ {usb_install_path}",
            bg=BG_COLOR, fg="#888", anchor="w", font=("Consolas", 9)
        )
        self.usb_origin_label.pack(side="left", padx=10, pady=10, fill="x", expand=True)
        self.origin_status = tk.Label(
            origin_frame,
            text="‚è≥ Verificando...",
            bg=BG_COLOR, fg=WARNING_COLOR, font=("Arial", 9, "italic")
        )
        self.origin_status.pack(side="right", padx=10, pady=10)
        self.update_usb_origin_status()
        btn_frame = tk.Frame(frame, bg=BG_COLOR)
        btn_frame.pack(pady=20)
        self.install_btn = ttk.Button(
            btn_frame,
            text="üöÄ Iniciar Instala√ß√£o USB",
            command=self.start_usb_install,
            style="Accent.TButton"
        )
        self.install_btn.pack(ipadx=20, ipady=8)
        log_frame = ttk.LabelFrame(frame, text="üìù Log de Opera√ß√£o")
        log_frame.pack(fill="both", expand=True, pady=10, padx=20)
        self.usb_log_text = tk.Text(log_frame, height=12, bg="#1b1b1b", fg=TEXT_COLOR, font=("Consolas", 9))
        self.usb_log_text.pack(fill="both", expand=True, padx=10, pady=10)
        self.usb_log_text.tag_config("error", foreground=ERROR_COLOR)
        self.usb_log_text.tag_config("success", foreground=SUCCESS_COLOR)
        self.usb_log_text.tag_config("warning", foreground=WARNING_COLOR)
        self.usb_log_text.tag_config("info", foreground="#aaa")
        self.usb_log_text.insert("1.0", ">>> Aguardando sele√ß√£o de destino...\n", "info")
        self.usb_log_text.config(state="disabled")

    def setup_console_tab(self):
        frame = ttk.Frame(self.tab_console)
        frame.pack(fill="both", expand=True, padx=10, pady=10)
        tk.Label(frame, text="‚å®Ô∏è Console", font=("Arial", 10, "bold")).pack(anchor="w")
        self.console_input = tk.Entry(frame, font=("Consolas", 10))
        self.console_input.pack(fill="x", pady=5)
        self.console_input.bind("<Return>", self.execute_console_command)
        self.console_output = tk.Text(frame, height=20, bg="#1e1e1e", fg="#00ff00", font=("Consolas", 10))
        self.console_output.pack(fill="both", expand=True, pady=5)
        self.console_output.insert("1.0", ">>> Console iniciado. Digite 'help'.\n")

    def execute_console_command(self, event=None):
        cmd = self.console_input.get().strip()
        self.console_output.insert("end", f">>> {cmd}\n")
        responses = {
            "help": "Comandos: help, clear, list, version",
            "clear": lambda: self.console_output.delete("1.0", "end"),
            "list": lambda: self.list_games_in_console(),
            "version": f"POPStation v{CURRENT_VERSION}"
        }
        if cmd in responses:
            if callable(responses[cmd]):
                responses[cmd]()
            else:
                self.console_output.insert("end", responses[cmd] + "\n")
        else:
            self.console_output.insert("end", "Comando n√£o reconhecido.\n")
        self.console_input.delete(0, "end")
        self.console_output.see("end")

    def list_games_in_console(self):
        if not self.target_dir:
            self.console_output.insert("end", "Nenhuma pasta selecionada.\n")
            return
        conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
        if not os.path.exists(conf_file):
            self.console_output.insert("end", "Nenhum jogo encontrado.\n")
            return
        with open(conf_file, 'r', encoding='utf-8') as f:
            for line in f:
                if "=" in line:
                    game_key, _ = line.strip().split("=", 1)
                    self.console_output.insert("end", f" - {game_key}\n")

    def find_bios_files(self):
        script_root = get_script_root()
        bios_files = []
        for file in os.listdir(script_root):
            if file.upper().startswith("BIOS") and file.upper().endswith(".BIN"):
                bios_files.append(file)
        return bios_files if bios_files else ["BIOS.BIN"]

    def log(self, message, level="info", advanced=False):
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        full_message = f"[{timestamp}] {message}"
        print(full_message)
        if advanced:
            tag = "error" if "‚ùå" in message else "success" if "‚úÖ" in message else ""
            self.advanced_log_text.insert(tk.END, full_message + "\n", tag)
            self.advanced_log_text.see(tk.END)
        else:
            tag = "error" if "‚ùå" in message or "Erro" in message else "success" if "‚úÖ" in message else "warning" if "‚ö†Ô∏è" in message else ""
            self.log_text.insert(tk.END, full_message + "\n", tag)
            self.log_text.see(tk.END)
        ensure_dir("logs")
        with open(os.path.join("logs", "popstation.log"), "a", encoding="utf-8") as f:
            f.write(full_message + "\n")
        self.status_var.set(message[:50] + "..." if len(message) > 50 else message)
        self.root.update_idletasks()

    def update_progress(self, message, value):
        self.progress_label.config(text=message)
        self.progress['value'] = value
        self.root.update_idletasks()

    def select_files(self):
        files = filedialog.askopenfilenames(
            filetypes=[("Jogos PS1/CHD", "*.iso *.bin *.cue *.mdf *.ecm *.img *.chd *.gdi *.zso")]
        )
        if files:
            self.files.extend(files)
            self.update_file_listbox()
            self.log(f"üì• {len(files)} arquivos selecionados.")

    def update_file_listbox(self):
        self.listbox.delete(0, tk.END)
        for f in self.files:
            self.listbox.insert(tk.END, os.path.basename(f))

    def select_folder(self):
        folder = filedialog.askdirectory()
        if folder:
            self.target_dir = folder
            self.dest_label.config(text=f"üìÅ {folder}")
            self.log(f"‚úÖ Pasta selecionada: {folder}")
            self.refresh_manage_tab()
            # Salva na configura√ß√£o
            config["last_folder"] = folder
            save_config(config)

    def open_target_folder(self):
        if self.target_dir and os.path.exists(self.target_dir):
            os.startfile(self.target_dir)
        else:
            messagebox.showwarning("Aviso", "Nenhuma pasta v√°lida selecionada!")

    def select_covers(self):
        for file_path in self.files:
            cover_path = filedialog.askopenfilename(
                title=f"Capa para {os.path.basename(file_path)}",
                filetypes=[("Imagens", "*.png *.jpg *.jpeg *.bmp")]
            )
            if cover_path:
                game_name = os.path.splitext(os.path.basename(file_path))[0]
                self.covers[game_name] = cover_path
                self.log(f"üñºÔ∏è Capa selecionada para {game_name}")

    def select_logos(self):
        for file_path in self.files:
            logo_path = filedialog.askopenfilename(
                title=f"Logo para {os.path.basename(file_path)}",
                filetypes=[("Imagens", "*.png *.jpg *.jpeg *.bmp")]
            )
            if logo_path:
                game_name = os.path.splitext(os.path.basename(file_path))[0]
                self.logos[game_name] = logo_path
                self.log(f"üîñ Logo selecionado para {game_name}")

    def process_games(self):
        if not self.files or not self.target_dir:
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Selecione arquivos e pasta destino!")
            return

        script_root = get_script_root()
        essential_files = [POPS_ELF_NAME, SLOT0_VMC_NAME, SLOT1_VMC_NAME]
        bios_selected = self.bios_var.get()
        if not os.path.exists(os.path.join(script_root, bios_selected)):
            messagebox.showerror("‚ùå Erro", f"BIOS n√£o encontrado: {bios_selected}")
            return

        essential_files.append(bios_selected)
        missing = []
        for f in essential_files:
            if not os.path.exists(os.path.join(script_root, f)):
                missing.append(f)
        if missing:
            messagebox.showerror("‚ùå Erro", f"Arquivos ausentes: {', '.join(missing)}")
            return

        total = len(self.files)
        self.progress['maximum'] = total * 100
        self.log(f"‚ñ∂Ô∏è Processando {total} jogos...")

        pops_dir = os.path.join(self.target_dir, POPS_DIR_NAME)
        ensure_dir(pops_dir)
        copy_file(os.path.join(script_root, bios_selected), os.path.join(pops_dir, BIOS_FILE_NAME))
        copy_file(os.path.join(script_root, POPS_ELF_NAME), os.path.join(pops_dir, "POPSTARTER.ELF"))

        copy_src = os.path.join(script_root, "_copy")
        if os.path.exists(copy_src):
            self.log(f"üì¶ Copiando conte√∫do de _copy para POPS...")
            copy_tree(copy_src, pops_dir, self.log)

        success_count = 0
        for i, f in enumerate(self.files):
            self.update_progress(f"Jogo {i+1}/{total}", i * 100)
            game_name = os.path.splitext(os.path.basename(f))[0]
            cover_path = self.covers.get(game_name)
            logo_path = self.logos.get(game_name)
            if process_game(f, pops_dir, self.target_dir, cover_path, logo_path, self.log, self.update_progress):
                success_count += 1

        self.update_progress("‚úÖ Conclu√≠do!", total * 100)
        self.log(f"üéâ {success_count}/{total} jogos processados!", "success")

        try:
            winsound.PlaySound(os.path.join(script_root, "success.wav"), winsound.SND_ASYNC)
        except:
            pass

        self.files = []
        self.covers = {}
        self.logos = {}
        self.listbox.delete(0, tk.END)
        self.log("üìã Lista limpa.")
        self.refresh_manage_tab()

        # Adiciona aos jogos recentes
        for f in self.files:
            if f not in config["recent_games"]:
                config["recent_games"].insert(0, f)
        config["recent_games"] = config["recent_games"][:10]  # Mant√©m apenas 10
        save_config(config)
        self.update_recent_list()

    def refresh_manage_tab(self):
        """Atualiza a lista de jogos com base no modo de exibi√ß√£o e no filtro de busca."""
        self.cover_images.clear()
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()
        self.game_tiles = {}

        if not self.target_dir:
            self.games_count_label.config(text=texts["lbl_games_count"].format(count="0"))
            self.disk_usage_label.config(text="üíæ Uso: -- / -- (---% livre)")
            tk.Label(
                self.scrollable_frame,
                text=texts["msg_no_folder"],
                bg=BG_COLOR, fg=ERROR_COLOR, font=("Arial", 11, "bold"), justify="center"
            ).pack(pady=50)
            return

        conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
        art_dir = os.path.join(self.target_dir, ART_DIR_NAME)
        pops_dir = os.path.join(self.target_dir, POPS_DIR_NAME)

        if not os.path.exists(conf_file):
            self.games_count_label.config(text=texts["lbl_games_count"].format(count="0"))
            self.disk_usage_label.config(text=f"üíæ Uso: -- / -- (---% livre)")
            tk.Label(
                self.scrollable_frame,
                text=texts["msg_no_conf"],
                bg=BG_COLOR, fg=ERROR_COLOR, font=("Arial", 11, "bold"), justify="center"
            ).pack(pady=50)
            return

        # Coleta jogos v√°lidos
        games = []
        try:
            with open(conf_file, 'r', encoding='utf-8') as f:
                for line in f:
                    if "=" in line:
                        game_key, elf = line.strip().split("=", 1)
                        elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
                        if not elf_name_no_ext:
                            continue
                        valid_game = any(
                            os.path.exists(os.path.join(pops_dir, f"{elf_name_no_ext}{ext}")) 
                            for ext in SUPPORTED_FORMATS + [".VCD"]
                        )
                        if valid_game:
                            games.append(game_key)
        except UnicodeDecodeError:
            self.games_count_label.config(text="üîç Jogos: 0")
            tk.Label(
                self.scrollable_frame,
                text="‚ùå Erro: 'conf_apps.cfg' est√° corrompido ou n√£o est√° em UTF-8.\nAbra o arquivo com o Bloco de Notas e salve como UTF-8.",
                bg=BG_COLOR, fg=ERROR_COLOR, font=("Arial", 10), justify="center"
            ).pack(pady=50)
            return
        except Exception as e:
            self.games_count_label.config(text="üîç Jogos: 0")
            tk.Label(
                self.scrollable_frame,
                text=f"‚ùå Erro ao ler conf_apps.cfg: {str(e)}",
                bg=BG_COLOR, fg=ERROR_COLOR, font=("Arial", 10), justify="center"
            ).pack(pady=50)
            return

        # Ordena alfabeticamente (ignorando case)
        games.sort(key=str.lower)

        # Aplica filtro de busca
        search_text = self.search_var.get().lower().strip()
        if search_text:
            games = [g for g in games if search_text in g.lower()]

        count = len(games)
        self.games_count_label.config(text=texts["lbl_games_count"].format(count=count))

        # Calcula uso de disco
        try:
            usage = shutil.disk_usage(self.target_dir)
            total_gb = usage.total / (1024**3)
            used_gb = usage.used / (1024**3)
            free_gb = usage.free / (1024**3)
            percent_used = (used_gb / total_gb) * 100 if total_gb > 0 else 0
            self.disk_usage_label.config(
                text=f"üíæ Uso: {used_gb:.1f} GB / {total_gb:.1f} GB ({free_gb:.1f} GB livre)"
            )
        except Exception as e:
            self.disk_usage_label.config(text=f"üíæ Uso: ‚ùå N√£o acess√≠vel ({str(e)})")

        # --- RENDERIZA√á√ÉO BASEADA NO MODO DE EXIBI√á√ÉO ---
        mode = self.view_mode.get()
        columns = 5 if mode == "grid" else 4

        if mode == "list":
            headers = ["Nome do Jogo", "Arquivo ELF", "Tamanho", "Status"]
            for col, header in enumerate(headers):
                tk.Label(
                    self.scrollable_frame,
                    text=header,
                    bg=TILE_BG,
                    fg=ACCENT_COLOR,
                    font=("Arial", 9, "bold"),
                    anchor="w",
                    relief="raised",
                    padx=8,
                    pady=5
                ).grid(row=0, column=col, sticky="ew", padx=1, pady=1)

            for idx, game_key in enumerate(games, start=1):
                elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
                elf_name = f"XX.{elf_name_no_ext}.ELF"
                vcd_path = os.path.join(pops_dir, f"{elf_name_no_ext}.VCD")
                # --- TAMANHO DO JOGO ---
                size_str = "N/A"
                if os.path.exists(vcd_path):
                    size_bytes = os.path.getsize(vcd_path)
                    if size_bytes < 1024**2:
                        size_str = f"{size_bytes / 1024:.1f} KB"
                    elif size_bytes < 1024**3:
                        size_str = f"{size_bytes / (1024**2):.1f} MB"
                    else:
                        size_str = f"{size_bytes / (1024**3):.1f} GB"
                status = "‚úÖ VCD" if os.path.exists(vcd_path) else "‚ö†Ô∏è Ausente"
                # Linha da tabela
                tk.Label(self.scrollable_frame, text=game_key, bg=BG_COLOR, fg=TEXT_COLOR, anchor="w", font=("Arial", 9)).grid(row=idx, column=0, sticky="ew", padx=1, pady=1)
                tk.Label(self.scrollable_frame, text=elf_name, bg=BG_COLOR, fg=TEXT_COLOR, anchor="w", font=("Arial", 9)).grid(row=idx, column=1, sticky="ew", padx=1, pady=1)
                tk.Label(self.scrollable_frame, text=size_str, bg=BG_COLOR, fg=TEXT_COLOR, anchor="w", font=("Arial", 9)).grid(row=idx, column=2, sticky="ew", padx=1, pady=1)
                tk.Label(self.scrollable_frame, text=status, bg=BG_COLOR, fg=SUCCESS_COLOR if status == "‚úÖ VCD" else WARNING_COLOR, anchor="w", font=("Arial", 9)).grid(row=idx, column=3, sticky="ew", padx=1, pady=1)
                # Menu contextual
                menu = tk.Menu(self.root, tearoff=0)
                menu.add_command(label="‚úèÔ∏è Renomear", command=lambda g=game_key: self.rename_game(g))
                menu.add_command(label="üóëÔ∏è Apagar", command=lambda g=game_key: self.delete_game(g))
                menu.add_command(label="üñºÔ∏è Atualizar Capa", command=lambda g=game_key: self.update_cover(g))
                menu.add_command(label="üîñ Atualizar Logo", command=lambda g=game_key: self.update_logo(g))
                menu.add_separator()
                menu.add_command(label="üíø Converter para CUE+BIN", command=lambda g=game_key: self.convert_game_to_cue_bin(g))
                menu.add_command(label="üìÄ Converter para ISO", command=lambda g=game_key: self.convert_game_to_iso(g))
                row_frame = tk.Frame(self.scrollable_frame, bg=BG_COLOR)
                row_frame.grid(row=idx, column=0, columnspan=4, sticky="ew", padx=1, pady=1)
                row_frame.bind("<Button-3>", lambda e, m=menu: m.tk_popup(e.x_root, e.y_root))
                for child in row_frame.winfo_children():
                    child.bind("<Button-3>", lambda e, m=menu: m.tk_popup(e.x_root, e.y_root))

        elif mode == "cards":
            columns = 4
            idx = 0
            for game_key in games:
                frame = tk.Frame(self.scrollable_frame, bg=TILE_BG, padx=8, pady=8, relief="raised", bd=1, width=180, height=200)
                frame.grid_propagate(False)
                frame.grid(row=idx // columns, column=idx % columns, padx=10, pady=10, sticky="n")
                self.game_tiles[game_key] = frame
                idx += 1
                elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
                cover_path = None
                logo_path = None
                for ext in [".png", ".jpg", ".jpeg", ".bmp"]:
                    test_cover = os.path.join(art_dir, f"XX.{elf_name_no_ext}.ELF_COV{ext}")
                    test_logo = os.path.join(art_dir, f"XX.{elf_name_no_ext}.ELF_LGO{ext}")
                    if os.path.exists(test_cover):
                        cover_path = test_cover
                    if os.path.exists(test_logo):
                        logo_path = test_logo
                # Imagem da capa (miniatura)
                if cover_path and os.path.exists(cover_path):
                    try:
                        img = Image.open(cover_path)
                        img.thumbnail((120, 120))
                        photo = ImageTk.PhotoImage(img)
                        self.cover_images[cover_path] = photo
                        lbl_cover = tk.Label(frame, image=photo, bg=TILE_BG)
                        lbl_cover.pack(pady=2)
                        ImageTooltip(lbl_cover, cover_path, PREVIEW_SIZE)
                    except Exception as e:
                        self.log(f"Erro ao carregar capa {cover_path}: {e}", "error")
                        lbl_cover = tk.Label(frame, text="‚ùå Capa", width=15, height=7, bg=TILE_BG, fg="red")
                        lbl_cover.pack(pady=2)
                else:
                    lbl_cover = tk.Label(frame, text="Sem capa", width=15, height=7, bg=TILE_BG, fg=TEXT_COLOR)
                    lbl_cover.pack(pady=2)
                # Nome do jogo
                tk.Label(frame, text=game_key, bg=TILE_BG, fg=TEXT_COLOR, wraplength=160, font=("Arial", 9, "bold")).pack(pady=2)
                # Tamanho
                vcd_path = os.path.join(pops_dir, f"{elf_name_no_ext}.VCD")
                size_str = "N/A"
                if os.path.exists(vcd_path):
                    size_bytes = os.path.getsize(vcd_path)
                    if size_bytes < 1024**2:
                        size_str = f"{size_bytes / 1024:.1f} KB"
                    elif size_bytes < 1024**3:
                        size_str = f"{size_bytes / (1024**2):.1f} MB"
                    else:
                        size_str = f"{size_bytes / (1024**3):.1f} GB"
                tk.Label(frame, text=f"Tamanho: {size_str}", bg=TILE_BG, fg=TEXT_COLOR, font=("Arial", 8)).pack(pady=1)
                # Status
                status = "‚úÖ" if os.path.exists(vcd_path) else "‚ùå"
                tk.Label(frame, text=status, bg=TILE_BG, fg=SUCCESS_COLOR if status == "‚úÖ" else ERROR_COLOR, font=("Arial", 8)).pack(pady=1)
                # Menu contextual
                menu = tk.Menu(self.root, tearoff=0)
                menu.add_command(label="‚úèÔ∏è Renomear", command=lambda g=game_key: self.rename_game(g))
                menu.add_command(label="üóëÔ∏è Apagar", command=lambda g=game_key: self.delete_game(g))
                menu.add_command(label="üñºÔ∏è Atualizar Capa", command=lambda g=game_key: self.update_cover(g))
                menu.add_command(label="üîñ Atualizar Logo", command=lambda g=game_key: self.update_logo(g))
                menu.add_separator()
                menu.add_command(label="üíø Converter para CUE+BIN", command=lambda g=game_key: self.convert_game_to_cue_bin(g))
                menu.add_command(label="üìÄ Converter para ISO", command=lambda g=game_key: self.convert_game_to_iso(g))
                frame.bind("<Button-3>", lambda e, m=menu: m.tk_popup(e.x_root, e.y_root))
                for child in frame.winfo_children():
                    child.bind("<Button-3>", lambda e, m=menu: m.tk_popup(e.x_root, e.y_root))

        else:  # mode == "grid" (padr√£o)
            columns = 5
            idx = 0
            for game_key in games:
                frame = tk.Frame(self.scrollable_frame, bg=TILE_BG, padx=5, pady=5, relief="raised", bd=1)
                frame.grid(row=idx // columns, column=idx % columns, padx=10, pady=10, sticky="n")
                self.game_tiles[game_key] = frame
                idx += 1
                elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
                cover_path = None
                logo_path = None
                for ext in [".png", ".jpg", ".jpeg", ".bmp"]:
                    test_cover = os.path.join(art_dir, f"XX.{elf_name_no_ext}.ELF_COV{ext}")
                    test_logo = os.path.join(art_dir, f"XX.{elf_name_no_ext}.ELF_LGO{ext}")
                    if os.path.exists(test_cover):
                        cover_path = test_cover
                    if os.path.exists(test_logo):
                        logo_path = test_logo
                # Capa
                if cover_path and os.path.exists(cover_path):
                    try:
                        img = Image.open(cover_path)
                        img.thumbnail(COVER_SIZE)
                        photo = ImageTk.PhotoImage(img)
                        self.cover_images[cover_path] = photo
                        lbl_cover = tk.Label(frame, image=photo, bg=TILE_BG)
                        lbl_cover.pack(pady=2)
                        ImageTooltip(lbl_cover, cover_path, PREVIEW_SIZE)
                    except Exception as e:
                        self.log(f"Erro ao carregar capa {cover_path}: {e}", "error")
                        lbl_cover = tk.Label(frame, text="Erro na capa", width=15, height=7, bg=TILE_BG, fg="red")
                        lbl_cover.pack(pady=2)
                else:
                    lbl_cover = tk.Label(frame, text="Sem capa", width=15, height=7, bg=TILE_BG, fg=TEXT_COLOR)
                    lbl_cover.pack(pady=2)
                # Logo (pequeno)
                if logo_path and os.path.exists(logo_path):
                    try:
                        img = Image.open(logo_path)
                        img.thumbnail(LOGO_SIZE)
                        photo = ImageTk.PhotoImage(img)
                        self.cover_images[logo_path] = photo
                        lbl_logo = tk.Label(frame, image=photo, bg=TILE_BG)
                        lbl_logo.pack(pady=2)
                        ImageTooltip(lbl_logo, logo_path, PREVIEW_SIZE)
                    except:
                        pass
                # Nome do jogo
                tk.Label(frame, text=game_key, bg=TILE_BG, fg=TEXT_COLOR, wraplength=150, font=("Arial", 9, "bold")).pack()
                # Arquivo ELF
                tk.Label(frame, text=os.path.basename(get_elf_name_from_game_key(game_key, self.target_dir)) + ".ELF", bg=TILE_BG, fg=TEXT_COLOR, font=("Arial", 8)).pack()
                # Tamanho do jogo
                vcd_path = os.path.join(pops_dir, f"{elf_name_no_ext}.VCD")
                size_str = "N/A"
                if os.path.exists(vcd_path):
                    size_bytes = os.path.getsize(vcd_path)
                    if size_bytes < 1024**2:
                        size_str = f"{size_bytes / 1024:.1f} KB"
                    elif size_bytes < 1024**3:
                        size_str = f"{size_bytes / (1024**2):.1f} MB"
                    else:
                        size_str = f"{size_bytes / (1024**3):.1f} GB"
                tk.Label(frame, text=f"Tamanho: {size_str}", bg=TILE_BG, fg=TEXT_COLOR, font=("Arial", 8)).pack()
                # Status VCD
                status = "‚úÖ" if os.path.exists(vcd_path) else "‚ùå"
                tk.Label(frame, text=status, bg=TILE_BG, fg=SUCCESS_COLOR if status == "‚úÖ" else ERROR_COLOR, font=("Arial", 8)).pack()
                # Menu contextual
                menu = tk.Menu(self.root, tearoff=0)
                menu.add_command(label="‚úèÔ∏è Renomear", command=lambda g=game_key: self.rename_game(g))
                menu.add_command(label="üóëÔ∏è Apagar", command=lambda g=game_key: self.delete_game(g))
                menu.add_command(label="üñºÔ∏è Atualizar Capa", command=lambda g=game_key: self.update_cover(g))
                menu.add_command(label="üîñ Atualizar Logo", command=lambda g=game_key: self.update_logo(g))
                menu.add_separator()
                menu.add_command(label="üíø Converter para CUE+BIN", command=lambda g=game_key: self.convert_game_to_cue_bin(g))
                menu.add_command(label="üìÄ Converter para ISO", command=lambda g=game_key: self.convert_game_to_iso(g))
                frame.bind("<Button-3>", lambda e, m=menu: m.tk_popup(e.x_root, e.y_root))
                for child in frame.winfo_children():
                    child.bind("<Button-3>", lambda e, m=menu: m.tk_popup(e.x_root, e.y_root))

    def rename_game(self, game_key):
        new_name = simpledialog.askstring("Renomear", f"Novo nome para '{game_key}':")
        if not new_name or not self.target_dir:
            return
        conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
        if not os.path.exists(conf_file):
            return
        backup_conf_file(self.target_dir)
        with open(conf_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        with open(conf_file, 'w', encoding='utf-8') as f:
            for line in lines:
                if line.startswith(game_key + "="):
                    f.write(line.replace(game_key, new_name, 1))
                else:
                    f.write(line)
        self.log(f"‚úèÔ∏è Renomeado: {game_key} ‚Üí {new_name}", "success")
        self.refresh_manage_tab()

    def delete_game(self, game_key):
        if not messagebox.askyesno("‚ö†Ô∏è Confirma√ß√£o", texts["msg_confirm_delete"].format(game_key=game_key)):
            return
        if not self.target_dir:
            return
        elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
        if not elf_name_no_ext:
            messagebox.showerror("‚ùå Erro", f"ELF n√£o encontrado para '{game_key}'")
            return
        backup_conf_file(self.target_dir)
        pops_dir = os.path.join(self.target_dir, POPS_DIR_NAME)
        art_dir = os.path.join(self.target_dir, ART_DIR_NAME)
        conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
        save_folder = os.path.join(pops_dir, elf_name_no_ext)
        if os.path.exists(save_folder):
            shutil.rmtree(save_folder)
        elf_path = os.path.join(self.target_dir, f"XX.{elf_name_no_ext}.ELF")
        if os.path.exists(elf_path):
            os.remove(elf_path)
        for ext in SUPPORTED_FORMATS + [".VCD"]:
            path = os.path.join(pops_dir, f"{elf_name_no_ext}{ext}")
            if os.path.exists(path):
                os.remove(path)
        for ext in [".png", ".jpg", ".jpeg", ".bmp"]:
            for prefix in [".ELF_COV", ".ELF_LGO"]:
                file_path = os.path.join(art_dir, f"XX.{elf_name_no_ext}{prefix}{ext}")
                if os.path.exists(file_path):
                    os.remove(file_path)
        if os.path.exists(conf_file):
            with open(conf_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            with open(conf_file, 'w', encoding='utf-8') as f:
                for line in lines:
                    if not line.startswith(game_key + "="):
                        f.write(line)
        self.log(f"üóëÔ∏è Jogo '{game_key}' removido.", "success")
        messagebox.showinfo("‚úÖ Sucesso", f"'{game_key}' removido.")
        self.refresh_manage_tab()

    def update_cover(self, game_key):
        cover_path = filedialog.askopenfilename(
            title=f"Capa para {game_key}",
            filetypes=[("Imagens", "*.png *.jpg *.jpeg *.bmp")]
        )
        if not cover_path or not self.target_dir:
            return
        elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
        if not elf_name_no_ext:
            messagebox.showerror("‚ùå Erro", f"ELF n√£o encontrado para '{game_key}'")
            return
        art_dir = os.path.join(self.target_dir, ART_DIR_NAME)
        saved_cover = save_cover(elf_name_no_ext, art_dir, cover_path)
        self.log(f"üñºÔ∏è Capa atualizada: {saved_cover}", "success")
        self.refresh_manage_tab()

    def update_logo(self, game_key):
        logo_path = filedialog.askopenfilename(
            title=f"Logo para {game_key}",
            filetypes=[("Imagens", "*.png *.jpg *.jpeg *.bmp")]
        )
        if not logo_path or not self.target_dir:
            return
        elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
        if not elf_name_no_ext:
            messagebox.showerror("‚ùå Erro", f"ELF n√£o encontrado para '{game_key}'")
            return
        art_dir = os.path.join(self.target_dir, ART_DIR_NAME)
        saved_logo = save_logo(elf_name_no_ext, art_dir, logo_path)
        self.log(f"üîñ Logo atualizado: {saved_logo}", "success")
        self.refresh_manage_tab()

    def convert_game_to_cue_bin(self, game_key):
        elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
        if not elf_name_no_ext:
            messagebox.showerror("Erro", f"ELF n√£o encontrado para '{game_key}'")
            return
        pops_dir = os.path.join(self.target_dir, POPS_DIR_NAME)
        source_path = os.path.join(pops_dir, f"{elf_name_no_ext}.VCD")
        if not os.path.exists(source_path):
            messagebox.showerror("Erro", f".VCD n√£o encontrado para '{game_key}'")
            return
        output_dir = filedialog.askdirectory(title="Salvar CUE+BIN")
        if not output_dir:
            return
        temp_vcd = os.path.join(output_dir, os.path.basename(source_path))
        shutil.copy2(source_path, temp_vcd)
        if convert_vcd_to_cue_bin_with_pops2cue(temp_vcd, log_callback=self.log):
            output_cue = os.path.splitext(temp_vcd)[0] + ".cue"
            output_bin = os.path.splitext(temp_vcd)[0] + ".bin"
            try:
                os.remove(temp_vcd)
                self.log(f"üóëÔ∏è Arquivo tempor√°rio deletado: {os.path.basename(temp_vcd)}", "success")
            except Exception as e:
                self.log(f"‚ö†Ô∏è N√£o foi poss√≠vel deletar o VCD tempor√°rio: {e}", "warning")
            messagebox.showinfo("Sucesso", f"Arquivos gerados:\n{output_cue}\n{output_bin}")
        else:
            messagebox.showerror("Erro", "Falha na convers√£o.")

    def convert_game_to_iso(self, game_key):
        elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
        if not elf_name_no_ext:
            messagebox.showerror("Erro", f"ELF n√£o encontrado para '{game_key}'")
            return
        pops_dir = os.path.join(self.target_dir, POPS_DIR_NAME)
        source_path = os.path.join(pops_dir, f"{elf_name_no_ext}.VCD")
        if not os.path.exists(source_path):
            messagebox.showerror("Erro", f".VCD n√£o encontrado para '{game_key}'")
            return
        output_dir = filedialog.askdirectory(title="Salvar ISO")
        if not output_dir:
            return
        output_iso = os.path.join(output_dir, f"{game_key}.iso")
        if convert_vcd_to_iso(source_path, output_iso, log_callback=self.log):
            messagebox.showinfo("Sucesso", f"Salvo em:\n{output_iso}")
        else:
            messagebox.showerror("Erro", "Falha na convers√£o.")

    def export_csv(self):
        if not self.target_dir:
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Nenhuma pasta selecionada!")
            return
        conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
        if not os.path.exists(conf_file):
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Nenhum jogo encontrado!")
            return
        games = []
        with open(conf_file, 'r', encoding='utf-8') as f:
            for line in f:
                if "=" in line:
                    game_key, elf = line.strip().split("=", 1)
                    elf_name = os.path.basename(elf.replace("mass:/", ""))
                    games.append([game_key, elf_name])
        export_path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV", "*.csv")], initialfile="jogos.csv")
        if not export_path:
            return
        with open(export_path, 'w', encoding='utf-8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(["Nome do Jogo", "Arquivo ELF"])
            writer.writerows(games)
        self.log(f"üìä Exportado: {export_path}", "success")
        messagebox.showinfo("‚úÖ Sucesso", f"Exportado para:\n{export_path}")

    def export_html(self):
        if not self.target_dir:
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Nenhuma pasta selecionada!")
            return
        conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
        if not os.path.exists(conf_file):
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Nenhum jogo encontrado!")
            return
        games = []
        with open(conf_file, 'r', encoding='utf-8') as f:
            for line in f:
                if "=" in line:
                    game_key, elf = line.strip().split("=", 1)
                    elf_name = os.path.basename(elf.replace("mass:/", ""))
                    games.append({"name": game_key, "elf": elf_name})
        html = f"""<!DOCTYPE html><html><head><title>Jogos POPStarter</title><meta charset="UTF-8"><style>body{{font-family:Arial,sans-serif;background:#222;color:#eee;margin:40px;}}h1{{color:#4a90e2;}}table{{width:100%;border-collapse:collapse;margin-top:20px;}}th,td{{padding:12px;border:1px solid #444;text-align:left;}}th{{background:#333;}}tr:nth-child(even){{background:#2a2a2a;}}</style></head><body><h1>üéÆ Lista de Jogos</h1><p>Gerado em: {datetime.datetime.now().strftime("%d/%m/%Y %H:%M:%S")}</p><table><tr><th>Nome do Jogo</th><th>Arquivo ELF</th></tr>"""
        for game in games:
            html += f"<tr><td>{game['name']}</td><td>{game['elf']}</td></tr>"
        html += "</table></body></html>"
        export_path = filedialog.asksaveasfilename(defaultextension=".html", filetypes=[("HTML", "*.html")], initialfile="jogos.html")
        if not export_path:
            return
        with open(export_path, 'w', encoding='utf-8') as f:
            f.write(html)
        self.log(f"üìä Exportado: {export_path}", "success")
        messagebox.showinfo("‚úÖ Sucesso", f"Exportado para:\n{export_path}")

    def verify_integrity(self):
        if not self.target_dir:
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Nenhuma pasta!")
            return
        self.log("üîç Verificando integridade...", "warning")
        conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
        if not os.path.exists(conf_file):
            self.log("‚ùå conf_apps.cfg n√£o encontrado.", "error")
            return
        pops_dir = os.path.join(self.target_dir, POPS_DIR_NAME)
        with open(conf_file, 'r', encoding='utf-8') as f:
            for line in f:
                if "=" in line:
                    game_key, elf = line.strip().split("=", 1)
                    elf_name = os.path.basename(elf.replace("mass:/", ""))
                    elf_path = os.path.join(self.target_dir, elf_name)
                    elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
                    if not os.path.exists(elf_path):
                        self.log(f"‚ùå ELF ausente: {elf_name}", "error")
                    vcd_path = os.path.join(pops_dir, f"{elf_name_no_ext}.VCD")
                    if not os.path.exists(vcd_path):
                        self.log(f"‚ö†Ô∏è VCD ausente: {elf_name_no_ext}", "warning")
        self.log("‚úÖ Verifica√ß√£o conclu√≠da!", "success")
        messagebox.showinfo("‚úÖ Conclu√≠do", "Verifica√ß√£o finalizada!")

    def toggle_theme(self):
        self.current_theme = "light" if self.current_theme == "dark" else "dark"
        if self.current_theme == "dark":
            self.root.configure(bg=BG_COLOR)
            self.status_bar.configure(bg="#333", fg="#aaa")
        else:
            self.root.configure(bg="white")
            self.status_bar.configure(bg="#ddd", fg="#333")
        self.log(f"üé® Tema: {self.current_theme}", "success")
        config["theme"] = self.current_theme
        save_config(config)

    def toggle_retro_mode(self, event=None):
        self.retro_mode = not self.retro_mode
        if self.retro_mode:
            try:
                font = tkfont.Font(family="Press Start 2P", size=10)
                self.root.option_add("*Font", font)
            except:
                self.root.option_add("*Font", ("Courier", 10))
            self.root.configure(bg="#0f0f23")
            self.status_bar.configure(bg="#1a1a3a", fg="#00ff00")
            self.log("üïπÔ∏è MODO RETRO ATIVADO!", "success")
        else:
            self.root.option_add("*Font", ("TkDefaultFont"))
            self.toggle_theme()
            self.toggle_theme()
            self.log("üé® Modo Retro desativado.", "success")

    def show_about(self):
        messagebox.showinfo("Sobre", f"POPStation v{CURRENT_VERSION}\nGerenciador POPStarter Ultimate para PS2.\nDesenvolvido para a comunidade PS2 Homebrew.\nPressione Ctrl+Shift+R para modo RETRO!")

    def select_advanced_file(self):
        file_path = filedialog.askopenfilename(
            filetypes=[("Todos formatos suportados", "*.chd *.cue *.bin *.iso *.vcd *.gdi *.zso")]
        )
        if file_path:
            self.advanced_files = [file_path]
            self.advanced_file_label.config(text=f"Arquivo: {os.path.basename(file_path)}")
            self.log(f"üì• Arquivo selecionado: {os.path.basename(file_path)}", advanced=True)

    def select_advanced_output(self):
        folder = filedialog.askdirectory()
        if folder:
            self.advanced_output_folder = folder
            self.advanced_output_label.config(text=f"Pasta: {folder}")
            self.log(f"üìÅ Pasta de sa√≠da selecionada: {folder}", advanced=True)

    def start_advanced_conversion(self):
        if not hasattr(self, 'advanced_files') or not self.advanced_files:
            messagebox.showwarning("Aviso", "Selecione um arquivo de origem!")
            return
        if not hasattr(self, 'advanced_output_folder'):
            messagebox.showwarning("Aviso", "Selecione uma pasta de sa√≠da!")
            return
        input_file = self.advanced_files[0]
        output_format = self.output_format.get()
        input_ext = os.path.splitext(input_file)[1].lower()
        base_name = os.path.splitext(os.path.basename(input_file))[0]
        script_root = get_script_root()
        chdman_path = os.path.join(script_root, CHDMAN_EXE)
        cue2pops_path = os.path.join(script_root, CUE2POPS_EXE)
        pops2cue_path = os.path.join(script_root, POPS2CUE_EXE)
        vcd2iso_path = os.path.join(script_root, VCD2ISO_EXE)
        ziso_path = os.path.join(script_root, ZISO_EXE)
        try:
            if output_format == "chd" and input_ext in [".cue", ".iso", ".gdi"]:
                if not os.path.exists(chdman_path):
                    self.log(f"‚ùå {CHDMAN_EXE} n√£o encontrado!", "error", advanced=True)
                    return
                output_chd = os.path.join(self.advanced_output_folder, f"{base_name}.chd")
                if convert_to_chd(input_file, output_chd, lambda msg: self.log(msg, advanced=True)):
                    self.log(f"‚úÖ CHD salvo: {output_chd}", "success", advanced=True)
            elif input_ext == ".chd" and output_format == "cue_bin":
                if not os.path.exists(chdman_path):
                    self.log(f"‚ùå {CHDMAN_EXE} n√£o encontrado!", "error", advanced=True)
                    return
                self.log(f"‚ñ∂Ô∏è Convertendo {os.path.basename(input_file)} para CUE+BIN...", advanced=True)
                cue_temp, bin_temp, temp_dir = convert_chd_to_iso_temp(
                    input_file,
                    lambda msg: self.log(msg, advanced=True),
                    None
                )
                if cue_temp and bin_temp and os.path.exists(cue_temp) and os.path.exists(bin_temp):
                    dest_cue = os.path.join(self.advanced_output_folder, os.path.basename(cue_temp))
                    dest_bin = os.path.join(self.advanced_output_folder, os.path.basename(bin_temp))
                    shutil.move(cue_temp, dest_cue)
                    shutil.move(bin_temp, dest_bin)
                    self.log(f"‚úÖ Arquivos movidos para: {self.advanced_output_folder}", "success", advanced=True)
                    self.log(f"   {os.path.basename(dest_cue)}", "success", advanced=True)
                    self.log(f"   {os.path.basename(dest_bin)}", "success", advanced=True)
                else:
                    self.log("‚ùå Falha na extra√ß√£o do CHD.", "error", advanced=True)
                if 'temp_dir' in locals() and temp_dir:
                    shutil.rmtree(temp_dir, ignore_errors=True)
            elif input_ext == ".chd" and output_format == "gdi":
                if not os.path.exists(chdman_path):
                    self.log(f"‚ùå {CHDMAN_EXE} n√£o encontrado!", "error", advanced=True)
                    return
                output_gdi = os.path.join(self.advanced_output_folder, f"{base_name}.gdi")
                if convert_chd_to_gdi(input_file, output_gdi, lambda msg: self.log(msg, advanced=True)):
                    self.log(f"‚úÖ GDI salvo: {output_gdi}", "success", advanced=True)
            elif input_ext == ".chd" and output_format == "iso":
                if not os.path.exists(chdman_path):
                    self.log(f"‚ùå {CHDMAN_EXE} n√£o encontrado!", "error", advanced=True)
                    return
                output_iso = os.path.join(self.advanced_output_folder, f"{base_name}.iso")
                if convert_chd_to_iso_only(input_file, output_iso, lambda msg: self.log(msg, advanced=True)):
                    self.log(f"‚úÖ ISO salvo: {output_iso}", "success", advanced=True)
            elif input_ext == ".cue" and output_format == "vcd":
                if not os.path.exists(cue2pops_path):
                    self.log(f"‚ùå {CUE2POPS_EXE} n√£o encontrado!", "error", advanced=True)
                    return
                bin_path = os.path.splitext(input_file)[0] + ".bin"
                if not os.path.exists(bin_path):
                    self.log(f"‚ùå Arquivo BIN n√£o encontrado: {bin_path}", "error", advanced=True)
                    return
                self.log(f"‚ñ∂Ô∏è Convertendo {os.path.basename(input_file)} para VCD...", advanced=True)
                output_path = os.path.join(self.advanced_output_folder, f"{base_name}.vcd")
                if convert_cue_to_vcd(input_file, output_path, lambda msg: self.log(msg, advanced=True)):
                    self.log(f"‚úÖ VCD salvo: {output_path}", "success", advanced=True)
            elif input_ext in [".iso", ".bin"] and output_format == "vcd":
                self.log(f"‚ñ∂Ô∏è Convertendo {os.path.basename(input_file)} para VCD...", advanced=True)
                output_path = os.path.join(self.advanced_output_folder, f"{base_name}.vcd")
                convert_to_vcd(input_file, output_path, lambda msg: self.log(msg, advanced=True))
                self.log(f"‚úÖ VCD salvo: {output_path}", "success", advanced=True)
            elif input_ext == ".vcd" and output_format == "cue_bin":
                if not os.path.exists(pops2cue_path):
                    self.log(f"‚ùå {POPS2CUE_EXE} n√£o encontrado!", "error", advanced=True)
                    return
                temp_vcd = os.path.join(self.advanced_output_folder, os.path.basename(input_file))
                shutil.copy2(input_file, temp_vcd)
                self.log(f"‚ñ∂Ô∏è Convertendo {os.path.basename(temp_vcd)} para CUE+BIN...", advanced=True)
                if convert_vcd_to_cue_bin_with_pops2cue(temp_vcd, lambda msg: self.log(msg, advanced=True)):
                    output_cue = os.path.splitext(temp_vcd)[0] + ".cue"
                    output_bin = os.path.splitext(temp_vcd)[0] + ".bin"
                    self.log(f"‚úÖ CUE+BIN salvos em: {self.advanced_output_folder}", "success", advanced=True)
                    self.log(f"   {os.path.basename(output_cue)}", "success", advanced=True)
                    self.log(f"   {os.path.basename(output_bin)}", "success", advanced=True)
                    try:
                        os.remove(temp_vcd)
                        self.log(f"üóëÔ∏è Arquivo tempor√°rio deletado: {os.path.basename(temp_vcd)}", "success", advanced=True)
                    except Exception as e:
                        self.log(f"‚ö†Ô∏è N√£o foi poss√≠vel deletar o VCD tempor√°rio: {e}", "warning", advanced=True)
                else:
                    self.log("‚ùå Falha na convers√£o com POPS2CUE.EXE.", "error", advanced=True)
            elif input_ext == ".vcd" and output_format == "iso":
                if not os.path.exists(vcd2iso_path):
                    self.log(f"‚ùå {VCD2ISO_EXE} n√£o encontrado!", "error", advanced=True)
                    return
                self.log(f"‚ñ∂Ô∏è Convertendo {os.path.basename(input_file)} para ISO...", advanced=True)
                output_iso = os.path.join(self.advanced_output_folder, f"{base_name}.iso")
                if convert_vcd_to_iso(input_file, output_iso, lambda msg: self.log(msg, advanced=True)):
                    self.log(f"‚úÖ ISO salvo: {output_iso}", "success", advanced=True)
            elif input_ext == ".iso" and output_format == "zso":
                if not os.path.exists(ziso_path):
                    self.log(f"‚ùå {ZISO_EXE} n√£o encontrado! Certifique-se de que est√° na pasta do script.", "error", advanced=True)
                    return
                output_zso = os.path.join(self.advanced_output_folder, f"{base_name}.zso")
                self.log(f"‚ñ∂Ô∏è Convertendo ISO ‚Üí ZSO: {os.path.basename(input_file)}", advanced=True)
                if convert_iso_to_zso(input_file, output_zso, lambda msg: self.log(msg, advanced=True)):
                    self.log(f"‚úÖ ZSO salvo: {output_zso}", "success", advanced=True)
                else:
                    self.log("‚ùå Falha na convers√£o ISO ‚Üí ZSO.", "error", advanced=True)
            elif input_ext == ".zso" and output_format == "iso":
                if not os.path.exists(ziso_path):
                    self.log(f"‚ùå {ZISO_EXE} n√£o encontrado! Certifique-se de que est√° na pasta do script.", "error", advanced=True)
                    return
                output_iso = os.path.join(self.advanced_output_folder, f"{base_name}.iso")
                self.log(f"‚ñ∂Ô∏è Convertendo ZSO ‚Üí ISO: {os.path.basename(input_file)}", advanced=True)
                if convert_zso_to_iso(input_file, output_iso, lambda msg: self.log(msg, advanced=True)):
                    self.log(f"‚úÖ ISO salvo: {output_iso}", "success", advanced=True)
                else:
                    self.log("‚ùå Falha na convers√£o ZSO ‚Üí ISO.", "error", advanced=True)
            else:
                self.log("‚ùå Convers√£o n√£o suportada para esta combina√ß√£o.", "error", advanced=True)
                return
            try:
                winsound.PlaySound(os.path.join(script_root, "success.wav"), winsound.SND_ASYNC)
            except:
                pass
        except Exception as e:
            self.log(f"‚ùå Erro: {e}", "error", advanced=True)

    def update_usb_origin_status(self):
        script_root = get_script_root()
        usb_install_path = os.path.join(script_root, "usb_install")
        if os.path.exists(usb_install_path) and os.listdir(usb_install_path):
            self.origin_status.config(text="‚úÖ Pronto!", fg=SUCCESS_COLOR)
        elif os.path.exists(usb_install_path):
            self.origin_status.config(text="‚ö†Ô∏è Pasta vazia!", fg=WARNING_COLOR)
        else:
            self.origin_status.config(text="‚ùå Pasta 'usb_install' n√£o encontrada!", fg=ERROR_COLOR)

    def select_usb_destination(self):
        folder = filedialog.askdirectory(title="Selecione a pasta de destino no USB")
        if not folder:
            return
        self.usb_dest = folder
        self.usb_dest_label.config(text=f"üìÅ {folder}")
        self.usb_log_text.config(state="normal")
        self.usb_log_text.delete("1.0", tk.END)
        self.usb_log_text.insert("1.0", f">>> Destino selecionado: {folder}\n", "info")
        self.usb_log_text.config(state="disabled")
        self.log_usb(f"üîå Destino USB definido: {folder}", "info")

    def start_usb_install(self):
        if not hasattr(self, 'usb_dest') or not self.usb_dest:
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Por favor, selecione um destino no USB!")
            return
        script_root = get_script_root()
        usb_install_path = os.path.join(script_root, "usb_install")
        if not os.path.exists(usb_install_path):
            self.log_usb("‚ùå Pasta 'usb_install' n√£o existe no diret√≥rio do script!", "error")
            return
        items = os.listdir(usb_install_path)
        if not items:
            self.log_usb("‚ö†Ô∏è A pasta 'usb_install' est√° vazia. Nada para copiar.", "warning")
            return
        total_items = len(items)
        self.log_usb(f"üöÄ Iniciando instala√ß√£o USB... ({total_items} itens)", "info")
        success_count = 0
        failed_count = 0
        skipped_count = 0
        for item in items:
            src = os.path.join(usb_install_path, item)
            dst = os.path.join(self.usb_dest, item)
            try:
                if os.path.isdir(src):
                    if os.path.exists(dst):
                        self.log_usb(f"üìÅ Mesclando pasta: {item}", "info")
                        copy_tree(src, dst, self.log)
                    else:
                        shutil.copytree(src, dst)
                        self.log_usb(f"üìÅ Copiado diret√≥rio: {item}", "success")
                else:
                    if os.path.exists(dst):
                        if os.path.getsize(src) == os.path.getsize(dst):
                            with open(src, 'rb') as f1, open(dst, 'rb') as f2:
                                if f1.read() == f2.read():
                                    self.log_usb(f"‚úÖ Ignorado (igual): {item}", "info")
                                    skipped_count += 1
                                    continue
                        shutil.copy2(src, dst)
                        self.log_usb(f"üìÑ Atualizado: {item}", "success")
                    else:
                        shutil.copy2(src, dst)
                        self.log_usb(f"üìÑ Copiado: {item}", "success")
                if sys.platform == "win32":
                    import ctypes
                    FILE_ATTRIBUTE_HIDDEN = 0x02
                    ctypes.windll.kernel32.SetFileAttributesW(dst, FILE_ATTRIBUTE_HIDDEN)
                    self.log_usb(f"üëÅÔ∏è  Ocultado: {item}", "info")
                success_count += 1
            except Exception as e:
                failed_count += 1
                self.log_usb(f"‚ùå Falha ao copiar '{item}': {str(e)}", "error")
        self.status_var.set(f"‚úÖ Conclu√≠do: {success_count} itens instalados")
        self.log_usb(f"\nüéâ INSTALA√á√ÉO CONCLU√çDA!\n   ‚úîÔ∏è Sucesso: {success_count}\n   ‚ö†Ô∏è Ignorados (iguais): {skipped_count}\n   ‚ùå Falhas: {failed_count}", "success")
        try:
            winsound.PlaySound(os.path.join(script_root, "success.wav"), winsound.SND_ASYNC)
        except:
            pass
        self.update_usb_origin_status()

    def log_usb(self, message, level="info"):
        self.usb_log_text.config(state="normal")
        tag = level
        self.usb_log_text.insert(tk.END, message + "\n", tag)
        self.usb_log_text.see(tk.END)
        self.usb_log_text.config(state="disabled")

    def verify_and_fix(self):
        """Verifica e corrige problemas comuns nos jogos."""
        if not self.target_dir:
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Selecione uma pasta de destino!")
            return

        conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
        pops_dir = os.path.join(self.target_dir, POPS_DIR_NAME)
        art_dir = os.path.join(self.target_dir, ART_DIR_NAME)

        if not os.path.exists(conf_file):
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Nenhum jogo encontrado para verificar!")
            return

        report = []
        fixed_count = 0

        # 1. Verifica se todos os jogos em conf_apps.cfg t√™m .VCD correspondente
        with open(conf_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        new_lines = []
        for line in lines:
            if "=" in line:
                game_key, elf = line.strip().split("=", 1)
                elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
                vcd_path = os.path.join(pops_dir, f"{elf_name_no_ext}.VCD")
                if not os.path.exists(vcd_path):
                    report.append(f"‚ùå {game_key}: .VCD ausente ({vcd_path})")
                else:
                    new_lines.append(line)
            else:
                new_lines.append(line)

        # 2. Verifica se as capas e logos est√£o no formato correto
        for line in lines:
            if "=" in line:
                game_key, _ = line.strip().split("=", 1)
                elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
                for ext in [".png", ".jpg", ".jpeg", ".bmp"]:
                    cover_path = os.path.join(art_dir, f"XX.{elf_name_no_ext}.ELF_COV{ext}")
                    logo_path = os.path.join(art_dir, f"XX.{elf_name_no_ext}.ELF_LGO{ext}")
                    if os.path.exists(cover_path):
                        report.append(f"‚úÖ Capa encontrada: {cover_path}")
                    if os.path.exists(logo_path):
                        report.append(f"‚úÖ Logo encontrado: {logo_path}")

        # 3. Salva o novo conf_apps.cfg (sem entradas inv√°lidas)
        if len(new_lines) != len(lines):
            with open(conf_file, 'w', encoding='utf-8') as f:
                f.writelines(new_lines)
            report.append(f"‚úÖ {len(lines)-len(new_lines)} entradas inv√°lidas removidas do conf_apps.cfg")
            fixed_count += 1

        # Mostra relat√≥rio
        if report:
            messagebox.showinfo("üîé Verificar e Corrigir", "\n".join(report))
        else:
            messagebox.showinfo("üîé Verificar e Corrigir", "‚úÖ Nenhum problema encontrado!")

    def export_zip_usb(self):
        """Compacta toda a estrutura (POPS/, ART/, conf_apps.cfg) em um .zip para USB."""
        if not self.target_dir:
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Selecione uma pasta de destino!")
            return

        zip_path = filedialog.asksaveasfilename(
            defaultextension=".zip",
            filetypes=[("Arquivo ZIP", "*.zip")],
            initialfile="POPStation_USB_Jogos.zip"
        )
        if not zip_path:
            return

        try:
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zf:
                # Adiciona POPS/
                pops_dir = os.path.join(self.target_dir, POPS_DIR_NAME)
                if os.path.exists(pops_dir):
                    for root, dirs, files in os.walk(pops_dir):
                        for file in files:
                            full_path = os.path.join(root, file)
                            arcname = os.path.relpath(full_path, self.target_dir)
                            zf.write(full_path, arcname)

                # Adiciona ART/
                art_dir = os.path.join(self.target_dir, ART_DIR_NAME)
                if os.path.exists(art_dir):
                    for root, dirs, files in os.walk(art_dir):
                        for file in files:
                            full_path = os.path.join(root, file)
                            arcname = os.path.relpath(full_path, self.target_dir)
                            zf.write(full_path, arcname)

                # Adiciona conf_apps.cfg
                conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
                if os.path.exists(conf_file):
                    zf.write(conf_file, "conf_apps.cfg")

                # Adiciona BIOS.BIN se existir
                bios_file = os.path.join(self.target_dir, POPS_DIR_NAME, "BIOS.BIN")
                if os.path.exists(bios_file):
                    zf.write(bios_file, os.path.join(POPS_DIR_NAME, "BIOS.BIN"))

            messagebox.showinfo("‚úÖ Exportar para USB", f"Arquivo compactado criado:\n{zip_path}")
            self.log(f"üíæ Exportado ZIP: {zip_path}", "success")
        except Exception as e:
            messagebox.showerror("‚ùå Erro", f"Falha ao criar o ZIP:\n{str(e)}")

    def check_for_updates(self):
        """Verifica se h√° nova vers√£o no GitHub."""
        try:
            response = requests.get("https://api.github.com/repos/yourusername/popstation/releases/latest", timeout=5)
            if response.status_code == 200:
                data = response.json()
                latest_version = data["tag_name"].replace("v", "")
                if latest_version > CURRENT_VERSION:
                    url = data["html_url"]
                    messagebox.showinfo(
                        "üÜï Nova Vers√£o Dispon√≠vel!",
                        texts["update_available"].format(new_version=latest_version, url=url)
                    )
                else:
                    messagebox.showinfo("‚úÖ Atualiza√ß√£o", texts["update_current"])
            else:
                messagebox.showwarning("‚ö†Ô∏è Falha", "N√£o foi poss√≠vel verificar atualiza√ß√µes.")
        except Exception as e:
            messagebox.showwarning("‚ö†Ô∏è Falha", f"Erro ao verificar atualiza√ß√µes:\n{str(e)}")

    def update_recent_list(self):
        """Atualiza a lista de jogos recentes na interface."""
        self.recent_listbox.delete(0, tk.END)
        for game in config["recent_games"]:
            self.recent_listbox.insert(tk.END, os.path.basename(game))

    def load_recent_game(self, event=None):
        """Carrega um jogo recente ao clicar duas vezes."""
        selection = self.recent_listbox.curselection()
        if selection:
            selected = self.recent_listbox.get(selection[0])
            full_path = None
            for game in config["recent_games"]:
                if os.path.basename(game) == selected:
                    full_path = game
                    break
            if full_path:
                self.files = [full_path]
                self.update_file_listbox()
                self.log(f"üìÅ Carregado jogo recente: {selected}")

    def clear_recent_list(self):
        """Limpa o hist√≥rico de jogos recentes."""
        config["recent_games"] = []
        save_config(config)
        self.update_recent_list()
        self.log("üóëÔ∏è Hist√≥rico de jogos recentes limpo.", "success")

    def select_folder(self):
        folder = filedialog.askdirectory()
        if folder:
            self.target_dir = folder
            self.dest_label.config(text=f"üìÅ {folder}")
            self.log(f"‚úÖ Pasta selecionada: {folder}")
            self.refresh_manage_tab()
            config["last_folder"] = folder
            save_config(config)

    def open_target_folder(self):
        if self.target_dir and os.path.exists(self.target_dir):
            os.startfile(self.target_dir)
        else:
            messagebox.showwarning("Aviso", "Nenhuma pasta v√°lida selecionada!")

    def select_covers(self):
        for file_path in self.files:
            cover_path = filedialog.askopenfilename(
                title=f"Capa para {os.path.basename(file_path)}",
                filetypes=[("Imagens", "*.png *.jpg *.jpeg *.bmp")]
            )
            if cover_path:
                game_name = os.path.splitext(os.path.basename(file_path))[0]
                self.covers[game_name] = cover_path
                self.log(f"üñºÔ∏è Capa selecionada para {game_name}")

    def select_logos(self):
        for file_path in self.files:
            logo_path = filedialog.askopenfilename(
                title=f"Logo para {os.path.basename(file_path)}",
                filetypes=[("Imagens", "*.png *.jpg *.jpeg *.bmp")]
            )
            if logo_path:
                game_name = os.path.splitext(os.path.basename(file_path))[0]
                self.logos[game_name] = logo_path
                self.log(f"üîñ Logo selecionado para {game_name}")

    def process_games(self):
        if not self.files or not self.target_dir:
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Selecione arquivos e pasta destino!")
            return

        script_root = get_script_root()
        essential_files = [POPS_ELF_NAME, SLOT0_VMC_NAME, SLOT1_VMC_NAME]
        bios_selected = self.bios_var.get()
        if not os.path.exists(os.path.join(script_root, bios_selected)):
            messagebox.showerror("‚ùå Erro", f"BIOS n√£o encontrado: {bios_selected}")
            return

        essential_files.append(bios_selected)
        missing = []
        for f in essential_files:
            if not os.path.exists(os.path.join(script_root, f)):
                missing.append(f)
        if missing:
            messagebox.showerror("‚ùå Erro", f"Arquivos ausentes: {', '.join(missing)}")
            return

        total = len(self.files)
        self.progress['maximum'] = total * 100
        self.log(f"‚ñ∂Ô∏è Processando {total} jogos...")

        pops_dir = os.path.join(self.target_dir, POPS_DIR_NAME)
        ensure_dir(pops_dir)
        copy_file(os.path.join(script_root, bios_selected), os.path.join(pops_dir, BIOS_FILE_NAME))
        copy_file(os.path.join(script_root, POPS_ELF_NAME), os.path.join(pops_dir, "POPSTARTER.ELF"))

        copy_src = os.path.join(script_root, "_copy")
        if os.path.exists(copy_src):
            self.log(f"üì¶ Copiando conte√∫do de _copy para POPS...")
            copy_tree(copy_src, pops_dir, self.log)

        success_count = 0
        for i, f in enumerate(self.files):
            self.update_progress(f"Jogo {i+1}/{total}", i * 100)
            game_name = os.path.splitext(os.path.basename(f))[0]
            cover_path = self.covers.get(game_name)
            logo_path = self.logos.get(game_name)

            # Modo PS1: for√ßa codifica√ß√£o ISO-8859-1 nos nomes
            if self.ps1_mode_var.get():
                game_name_encoded = game_name.encode('iso-8859-1').decode('iso-8859-1')
                # Ajusta o nome interno para evitar erros de encoding
                # Isso ser√° tratado internamente pelo popstation_core

            if process_game(f, pops_dir, self.target_dir, cover_path, logo_path, self.log, self.update_progress):
                success_count += 1

        self.update_progress("‚úÖ Conclu√≠do!", total * 100)
        self.log(f"üéâ {success_count}/{total} jogos processados!", "success")

        try:
            winsound.PlaySound(os.path.join(script_root, "success.wav"), winsound.SND_ASYNC)
        except:
            pass

        self.files = []
        self.covers = {}
        self.logos = {}
        self.listbox.delete(0, tk.END)
        self.log("üìã Lista limpa.")
        self.refresh_manage_tab()

        # Adiciona aos jogos recentes
        for f in self.files:
            if f not in config["recent_games"]:
                config["recent_games"].insert(0, f)
        config["recent_games"] = config["recent_games"][:10]  # Mant√©m apenas 10
        save_config(config)
        self.update_recent_list()

    def refresh_manage_tab(self):
        """Atualiza a lista de jogos com base no modo de exibi√ß√£o e no filtro de busca."""
        self.cover_images.clear()
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()
        self.game_tiles = {}

        if not self.target_dir:
            self.games_count_label.config(text=texts["lbl_games_count"].format(count="0"))
            self.disk_usage_label.config(text="üíæ Uso: -- / -- (---% livre)")
            tk.Label(
                self.scrollable_frame,
                text=texts["msg_no_folder"],
                bg=BG_COLOR, fg=ERROR_COLOR, font=("Arial", 11, "bold"), justify="center"
            ).pack(pady=50)
            return

        conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
        art_dir = os.path.join(self.target_dir, ART_DIR_NAME)
        pops_dir = os.path.join(self.target_dir, POPS_DIR_NAME)

        if not os.path.exists(conf_file):
            self.games_count_label.config(text=texts["lbl_games_count"].format(count="0"))
            self.disk_usage_label.config(text=f"üíæ Uso: -- / -- (---% livre)")
            tk.Label(
                self.scrollable_frame,
                text=texts["msg_no_conf"],
                bg=BG_COLOR, fg=ERROR_COLOR, font=("Arial", 11, "bold"), justify="center"
            ).pack(pady=50)
            return

        # Coleta jogos v√°lidos
        games = []
        try:
            with open(conf_file, 'r', encoding='utf-8') as f:
                for line in f:
                    if "=" in line:
                        game_key, elf = line.strip().split("=", 1)
                        elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
                        if not elf_name_no_ext:
                            continue
                        valid_game = any(
                            os.path.exists(os.path.join(pops_dir, f"{elf_name_no_ext}{ext}")) 
                            for ext in SUPPORTED_FORMATS + [".VCD"]
                        )
                        if valid_game:
                            games.append(game_key)
        except UnicodeDecodeError:
            self.games_count_label.config(text="üîç Jogos: 0")
            tk.Label(
                self.scrollable_frame,
                text="‚ùå Erro: 'conf_apps.cfg' est√° corrompido ou n√£o est√° em UTF-8.\nAbra o arquivo com o Bloco de Notas e salve como UTF-8.",
                bg=BG_COLOR, fg=ERROR_COLOR, font=("Arial", 10), justify="center"
            ).pack(pady=50)
            return
        except Exception as e:
            self.games_count_label.config(text="üîç Jogos: 0")
            tk.Label(
                self.scrollable_frame,
                text=f"‚ùå Erro ao ler conf_apps.cfg: {str(e)}",
                bg=BG_COLOR, fg=ERROR_COLOR, font=("Arial", 10), justify="center"
            ).pack(pady=50)
            return

        # Ordena alfabeticamente (ignorando case)
        games.sort(key=str.lower)

        # Aplica filtro de busca
        search_text = self.search_var.get().lower().strip()
        if search_text:
            games = [g for g in games if search_text in g.lower()]

        count = len(games)
        self.games_count_label.config(text=texts["lbl_games_count"].format(count=count))

        # Calcula uso de disco
        try:
            usage = shutil.disk_usage(self.target_dir)
            total_gb = usage.total / (1024**3)
            used_gb = usage.used / (1024**3)
            free_gb = usage.free / (1024**3)
            percent_used = (used_gb / total_gb) * 100 if total_gb > 0 else 0
            self.disk_usage_label.config(
                text=f"üíæ Uso: {used_gb:.1f} GB / {total_gb:.1f} GB ({free_gb:.1f} GB livre)"
            )
        except Exception as e:
            self.disk_usage_label.config(text=f"üíæ Uso: ‚ùå N√£o acess√≠vel ({str(e)})")

        # --- RENDERIZA√á√ÉO BASEADA NO MODO DE EXIBI√á√ÉO ---
        mode = self.view_mode.get()
        columns = 5 if mode == "grid" else 4

        if mode == "list":
            headers = ["Nome do Jogo", "Arquivo ELF", "Tamanho", "Status"]
            for col, header in enumerate(headers):
                tk.Label(
                    self.scrollable_frame,
                    text=header,
                    bg=TILE_BG,
                    fg=ACCENT_COLOR,
                    font=("Arial", 9, "bold"),
                    anchor="w",
                    relief="raised",
                    padx=8,
                    pady=5
                ).grid(row=0, column=col, sticky="ew", padx=1, pady=1)

            for idx, game_key in enumerate(games, start=1):
                elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
                elf_name = f"XX.{elf_name_no_ext}.ELF"
                vcd_path = os.path.join(pops_dir, f"{elf_name_no_ext}.VCD")
                # --- TAMANHO DO JOGO ---
                size_str = "N/A"
                if os.path.exists(vcd_path):
                    size_bytes = os.path.getsize(vcd_path)
                    if size_bytes < 1024**2:
                        size_str = f"{size_bytes / 1024:.1f} KB"
                    elif size_bytes < 1024**3:
                        size_str = f"{size_bytes / (1024**2):.1f} MB"
                    else:
                        size_str = f"{size_bytes / (1024**3):.1f} GB"
                status = "‚úÖ VCD" if os.path.exists(vcd_path) else "‚ö†Ô∏è Ausente"
                # Linha da tabela
                tk.Label(self.scrollable_frame, text=game_key, bg=BG_COLOR, fg=TEXT_COLOR, anchor="w", font=("Arial", 9)).grid(row=idx, column=0, sticky="ew", padx=1, pady=1)
                tk.Label(self.scrollable_frame, text=elf_name, bg=BG_COLOR, fg=TEXT_COLOR, anchor="w", font=("Arial", 9)).grid(row=idx, column=1, sticky="ew", padx=1, pady=1)
                tk.Label(self.scrollable_frame, text=size_str, bg=BG_COLOR, fg=TEXT_COLOR, anchor="w", font=("Arial", 9)).grid(row=idx, column=2, sticky="ew", padx=1, pady=1)
                tk.Label(self.scrollable_frame, text=status, bg=BG_COLOR, fg=SUCCESS_COLOR if status == "‚úÖ VCD" else WARNING_COLOR, anchor="w", font=("Arial", 9)).grid(row=idx, column=3, sticky="ew", padx=1, pady=1)
                # Menu contextual
                menu = tk.Menu(self.root, tearoff=0)
                menu.add_command(label="‚úèÔ∏è Renomear", command=lambda g=game_key: self.rename_game(g))
                menu.add_command(label="üóëÔ∏è Apagar", command=lambda g=game_key: self.delete_game(g))
                menu.add_command(label="üñºÔ∏è Atualizar Capa", command=lambda g=game_key: self.update_cover(g))
                menu.add_command(label="üîñ Atualizar Logo", command=lambda g=game_key: self.update_logo(g))
                menu.add_separator()
                menu.add_command(label="üíø Converter para CUE+BIN", command=lambda g=game_key: self.convert_game_to_cue_bin(g))
                menu.add_command(label="üìÄ Converter para ISO", command=lambda g=game_key: self.convert_game_to_iso(g))
                row_frame = tk.Frame(self.scrollable_frame, bg=BG_COLOR)
                row_frame.grid(row=idx, column=0, columnspan=4, sticky="ew", padx=1, pady=1)
                row_frame.bind("<Button-3>", lambda e, m=menu: m.tk_popup(e.x_root, e.y_root))
                for child in row_frame.winfo_children():
                    child.bind("<Button-3>", lambda e, m=menu: m.tk_popup(e.x_root, e.y_root))

        elif mode == "cards":
            columns = 4
            idx = 0
            for game_key in games:
                frame = tk.Frame(self.scrollable_frame, bg=TILE_BG, padx=8, pady=8, relief="raised", bd=1, width=180, height=200)
                frame.grid_propagate(False)
                frame.grid(row=idx // columns, column=idx % columns, padx=10, pady=10, sticky="n")
                self.game_tiles[game_key] = frame
                idx += 1
                elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
                cover_path = None
                logo_path = None
                for ext in [".png", ".jpg", ".jpeg", ".bmp"]:
                    test_cover = os.path.join(art_dir, f"XX.{elf_name_no_ext}.ELF_COV{ext}")
                    test_logo = os.path.join(art_dir, f"XX.{elf_name_no_ext}.ELF_LGO{ext}")
                    if os.path.exists(test_cover):
                        cover_path = test_cover
                    if os.path.exists(test_logo):
                        logo_path = test_logo
                # Imagem da capa (miniatura)
                if cover_path and os.path.exists(cover_path):
                    try:
                        img = Image.open(cover_path)
                        img.thumbnail((120, 120))
                        photo = ImageTk.PhotoImage(img)
                        self.cover_images[cover_path] = photo
                        lbl_cover = tk.Label(frame, image=photo, bg=TILE_BG)
                        lbl_cover.pack(pady=2)
                        ImageTooltip(lbl_cover, cover_path, PREVIEW_SIZE)
                    except Exception as e:
                        self.log(f"Erro ao carregar capa {cover_path}: {e}", "error")
                        lbl_cover = tk.Label(frame, text="‚ùå Capa", width=15, height=7, bg=TILE_BG, fg="red")
                        lbl_cover.pack(pady=2)
                else:
                    lbl_cover = tk.Label(frame, text="Sem capa", width=15, height=7, bg=TILE_BG, fg=TEXT_COLOR)
                    lbl_cover.pack(pady=2)
                # Nome do jogo
                tk.Label(frame, text=game_key, bg=TILE_BG, fg=TEXT_COLOR, wraplength=160, font=("Arial", 9, "bold")).pack(pady=2)
                # Tamanho
                vcd_path = os.path.join(pops_dir, f"{elf_name_no_ext}.VCD")
                size_str = "N/A"
                if os.path.exists(vcd_path):
                    size_bytes = os.path.getsize(vcd_path)
                    if size_bytes < 1024**2:
                        size_str = f"{size_bytes / 1024:.1f} KB"
                    elif size_bytes < 1024**3:
                        size_str = f"{size_bytes / (1024**2):.1f} MB"
                    else:
                        size_str = f"{size_bytes / (1024**3):.1f} GB"
                tk.Label(frame, text=f"Tamanho: {size_str}", bg=TILE_BG, fg=TEXT_COLOR, font=("Arial", 8)).pack(pady=1)
                # Status
                status = "‚úÖ" if os.path.exists(vcd_path) else "‚ùå"
                tk.Label(frame, text=status, bg=TILE_BG, fg=SUCCESS_COLOR if status == "‚úÖ" else ERROR_COLOR, font=("Arial", 8)).pack(pady=1)
                # Menu contextual
                menu = tk.Menu(self.root, tearoff=0)
                menu.add_command(label="‚úèÔ∏è Renomear", command=lambda g=game_key: self.rename_game(g))
                menu.add_command(label="üóëÔ∏è Apagar", command=lambda g=game_key: self.delete_game(g))
                menu.add_command(label="üñºÔ∏è Atualizar Capa", command=lambda g=game_key: self.update_cover(g))
                menu.add_command(label="üîñ Atualizar Logo", command=lambda g=game_key: self.update_logo(g))
                menu.add_separator()
                menu.add_command(label="üíø Converter para CUE+BIN", command=lambda g=game_key: self.convert_game_to_cue_bin(g))
                menu.add_command(label="üìÄ Converter para ISO", command=lambda g=game_key: self.convert_game_to_iso(g))
                frame.bind("<Button-3>", lambda e, m=menu: m.tk_popup(e.x_root, e.y_root))
                for child in frame.winfo_children():
                    child.bind("<Button-3>", lambda e, m=menu: m.tk_popup(e.x_root, e.y_root))

        else:  # mode == "grid" (padr√£o)
            columns = 5
            idx = 0
            for game_key in games:
                frame = tk.Frame(self.scrollable_frame, bg=TILE_BG, padx=5, pady=5, relief="raised", bd=1)
                frame.grid(row=idx // columns, column=idx % columns, padx=10, pady=10, sticky="n")
                self.game_tiles[game_key] = frame
                idx += 1
                elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
                cover_path = None
                logo_path = None
                for ext in [".png", ".jpg", ".jpeg", ".bmp"]:
                    test_cover = os.path.join(art_dir, f"XX.{elf_name_no_ext}.ELF_COV{ext}")
                    test_logo = os.path.join(art_dir, f"XX.{elf_name_no_ext}.ELF_LGO{ext}")
                    if os.path.exists(test_cover):
                        cover_path = test_cover
                    if os.path.exists(test_logo):
                        logo_path = test_logo
                # Capa
                if cover_path and os.path.exists(cover_path):
                    try:
                        img = Image.open(cover_path)
                        img.thumbnail(COVER_SIZE)
                        photo = ImageTk.PhotoImage(img)
                        self.cover_images[cover_path] = photo
                        lbl_cover = tk.Label(frame, image=photo, bg=TILE_BG)
                        lbl_cover.pack(pady=2)
                        ImageTooltip(lbl_cover, cover_path, PREVIEW_SIZE)
                    except Exception as e:
                        self.log(f"Erro ao carregar capa {cover_path}: {e}", "error")
                        lbl_cover = tk.Label(frame, text="Erro na capa", width=15, height=7, bg=TILE_BG, fg="red")
                        lbl_cover.pack(pady=2)
                else:
                    lbl_cover = tk.Label(frame, text="Sem capa", width=15, height=7, bg=TILE_BG, fg=TEXT_COLOR)
                    lbl_cover.pack(pady=2)
                # Logo (pequeno)
                if logo_path and os.path.exists(logo_path):
                    try:
                        img = Image.open(logo_path)
                        img.thumbnail(LOGO_SIZE)
                        photo = ImageTk.PhotoImage(img)
                        self.cover_images[logo_path] = photo
                        lbl_logo = tk.Label(frame, image=photo, bg=TILE_BG)
                        lbl_logo.pack(pady=2)
                        ImageTooltip(lbl_logo, logo_path, PREVIEW_SIZE)
                    except:
                        pass
                # Nome do jogo
                tk.Label(frame, text=game_key, bg=TILE_BG, fg=TEXT_COLOR, wraplength=150, font=("Arial", 9, "bold")).pack()
                # Arquivo ELF
                tk.Label(frame, text=os.path.basename(get_elf_name_from_game_key(game_key, self.target_dir)) + ".ELF", bg=TILE_BG, fg=TEXT_COLOR, font=("Arial", 8)).pack()
                # Tamanho do jogo
                vcd_path = os.path.join(pops_dir, f"{elf_name_no_ext}.VCD")
                size_str = "N/A"
                if os.path.exists(vcd_path):
                    size_bytes = os.path.getsize(vcd_path)
                    if size_bytes < 1024**2:
                        size_str = f"{size_bytes / 1024:.1f} KB"
                    elif size_bytes < 1024**3:
                        size_str = f"{size_bytes / (1024**2):.1f} MB"
                    else:
                        size_str = f"{size_bytes / (1024**3):.1f} GB"
                tk.Label(frame, text=f"Tamanho: {size_str}", bg=TILE_BG, fg=TEXT_COLOR, font=("Arial", 8)).pack()
                # Status VCD
                status = "‚úÖ" if os.path.exists(vcd_path) else "‚ùå"
                tk.Label(frame, text=status, bg=TILE_BG, fg=SUCCESS_COLOR if status == "‚úÖ" else ERROR_COLOR, font=("Arial", 8)).pack()
                # Menu contextual
                menu = tk.Menu(self.root, tearoff=0)
                menu.add_command(label="‚úèÔ∏è Renomear", command=lambda g=game_key: self.rename_game(g))
                menu.add_command(label="üóëÔ∏è Apagar", command=lambda g=game_key: self.delete_game(g))
                menu.add_command(label="üñºÔ∏è Atualizar Capa", command=lambda g=game_key: self.update_cover(g))
                menu.add_command(label="üîñ Atualizar Logo", command=lambda g=game_key: self.update_logo(g))
                menu.add_separator()
                menu.add_command(label="üíø Converter para CUE+BIN", command=lambda g=game_key: self.convert_game_to_cue_bin(g))
                menu.add_command(label="üìÄ Converter para ISO", command=lambda g=game_key: self.convert_game_to_iso(g))
                frame.bind("<Button-3>", lambda e, m=menu: m.tk_popup(e.x_root, e.y_root))
                for child in frame.winfo_children():
                    child.bind("<Button-3>", lambda e, m=menu: m.tk_popup(e.x_root, e.y_root))

    def rename_game(self, game_key):
        new_name = simpledialog.askstring("Renomear", f"Novo nome para '{game_key}':")
        if not new_name or not self.target_dir:
            return
        conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
        if not os.path.exists(conf_file):
            return
        backup_conf_file(self.target_dir)
        with open(conf_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        with open(conf_file, 'w', encoding='utf-8') as f:
            for line in lines:
                if line.startswith(game_key + "="):
                    f.write(line.replace(game_key, new_name, 1))
                else:
                    f.write(line)
        self.log(f"‚úèÔ∏è Renomeado: {game_key} ‚Üí {new_name}", "success")
        self.refresh_manage_tab()

    def delete_game(self, game_key):
        if not messagebox.askyesno("‚ö†Ô∏è Confirma√ß√£o", texts["msg_confirm_delete"].format(game_key=game_key)):
            return
        if not self.target_dir:
            return
        elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
        if not elf_name_no_ext:
            messagebox.showerror("‚ùå Erro", f"ELF n√£o encontrado para '{game_key}'")
            return
        backup_conf_file(self.target_dir)
        pops_dir = os.path.join(self.target_dir, POPS_DIR_NAME)
        art_dir = os.path.join(self.target_dir, ART_DIR_NAME)
        conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
        save_folder = os.path.join(pops_dir, elf_name_no_ext)
        if os.path.exists(save_folder):
            shutil.rmtree(save_folder)
        elf_path = os.path.join(self.target_dir, f"XX.{elf_name_no_ext}.ELF")
        if os.path.exists(elf_path):
            os.remove(elf_path)
        for ext in SUPPORTED_FORMATS + [".VCD"]:
            path = os.path.join(pops_dir, f"{elf_name_no_ext}{ext}")
            if os.path.exists(path):
                os.remove(path)
        for ext in [".png", ".jpg", ".jpeg", ".bmp"]:
            for prefix in [".ELF_COV", ".ELF_LGO"]:
                file_path = os.path.join(art_dir, f"XX.{elf_name_no_ext}{prefix}{ext}")
                if os.path.exists(file_path):
                    os.remove(file_path)
        if os.path.exists(conf_file):
            with open(conf_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            with open(conf_file, 'w', encoding='utf-8') as f:
                for line in lines:
                    if not line.startswith(game_key + "="):
                        f.write(line)
        self.log(f"üóëÔ∏è Jogo '{game_key}' removido.", "success")
        messagebox.showinfo("‚úÖ Sucesso", f"'{game_key}' removido.")
        self.refresh_manage_tab()

    def update_cover(self, game_key):
        cover_path = filedialog.askopenfilename(
            title=f"Capa para {game_key}",
            filetypes=[("Imagens", "*.png *.jpg *.jpeg *.bmp")]
        )
        if not cover_path or not self.target_dir:
            return
        elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
        if not elf_name_no_ext:
            messagebox.showerror("‚ùå Erro", f"ELF n√£o encontrado para '{game_key}'")
            return
        art_dir = os.path.join(self.target_dir, ART_DIR_NAME)
        saved_cover = save_cover(elf_name_no_ext, art_dir, cover_path)
        self.log(f"üñºÔ∏è Capa atualizada: {saved_cover}", "success")
        self.refresh_manage_tab()

    def update_logo(self, game_key):
        logo_path = filedialog.askopenfilename(
            title=f"Logo para {game_key}",
            filetypes=[("Imagens", "*.png *.jpg *.jpeg *.bmp")]
        )
        if not logo_path or not self.target_dir:
            return
        elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
        if not elf_name_no_ext:
            messagebox.showerror("‚ùå Erro", f"ELF n√£o encontrado para '{game_key}'")
            return
        art_dir = os.path.join(self.target_dir, ART_DIR_NAME)
        saved_logo = save_logo(elf_name_no_ext, art_dir, logo_path)
        self.log(f"üîñ Logo atualizado: {saved_logo}", "success")
        self.refresh_manage_tab()

    def convert_game_to_cue_bin(self, game_key):
        elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
        if not elf_name_no_ext:
            messagebox.showerror("Erro", f"ELF n√£o encontrado para '{game_key}'")
            return
        pops_dir = os.path.join(self.target_dir, POPS_DIR_NAME)
        source_path = os.path.join(pops_dir, f"{elf_name_no_ext}.VCD")
        if not os.path.exists(source_path):
            messagebox.showerror("Erro", f".VCD n√£o encontrado para '{game_key}'")
            return
        output_dir = filedialog.askdirectory(title="Salvar CUE+BIN")
        if not output_dir:
            return
        temp_vcd = os.path.join(output_dir, os.path.basename(source_path))
        shutil.copy2(source_path, temp_vcd)
        if convert_vcd_to_cue_bin_with_pops2cue(temp_vcd, log_callback=self.log):
            output_cue = os.path.splitext(temp_vcd)[0] + ".cue"
            output_bin = os.path.splitext(temp_vcd)[0] + ".bin"
            try:
                os.remove(temp_vcd)
                self.log(f"üóëÔ∏è Arquivo tempor√°rio deletado: {os.path.basename(temp_vcd)}", "success")
            except Exception as e:
                self.log(f"‚ö†Ô∏è N√£o foi poss√≠vel deletar o VCD tempor√°rio: {e}", "warning")
            messagebox.showinfo("Sucesso", f"Arquivos gerados:\n{output_cue}\n{output_bin}")
        else:
            messagebox.showerror("Erro", "Falha na convers√£o.")

    def convert_game_to_iso(self, game_key):
        elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
        if not elf_name_no_ext:
            messagebox.showerror("Erro", f"ELF n√£o encontrado para '{game_key}'")
            return
        pops_dir = os.path.join(self.target_dir, POPS_DIR_NAME)
        source_path = os.path.join(pops_dir, f"{elf_name_no_ext}.VCD")
        if not os.path.exists(source_path):
            messagebox.showerror("Erro", f".VCD n√£o encontrado para '{game_key}'")
            return
        output_dir = filedialog.askdirectory(title="Salvar ISO")
        if not output_dir:
            return
        output_iso = os.path.join(output_dir, f"{game_key}.iso")
        if convert_vcd_to_iso(source_path, output_iso, log_callback=self.log):
            messagebox.showinfo("Sucesso", f"Salvo em:\n{output_iso}")
        else:
            messagebox.showerror("Erro", "Falha na convers√£o.")

    def export_csv(self):
        if not self.target_dir:
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Nenhuma pasta selecionada!")
            return
        conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
        if not os.path.exists(conf_file):
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Nenhum jogo encontrado!")
            return
        games = []
        with open(conf_file, 'r', encoding='utf-8') as f:
            for line in f:
                if "=" in line:
                    game_key, elf = line.strip().split("=", 1)
                    elf_name = os.path.basename(elf.replace("mass:/", ""))
                    games.append([game_key, elf_name])
        export_path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV", "*.csv")], initialfile="jogos.csv")
        if not export_path:
            return
        with open(export_path, 'w', encoding='utf-8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(["Nome do Jogo", "Arquivo ELF"])
            writer.writerows(games)
        self.log(f"üìä Exportado: {export_path}", "success")
        messagebox.showinfo("‚úÖ Sucesso", f"Exportado para:\n{export_path}")

    def export_html(self):
        if not self.target_dir:
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Nenhuma pasta selecionada!")
            return
        conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
        if not os.path.exists(conf_file):
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Nenhum jogo encontrado!")
            return
        games = []
        with open(conf_file, 'r', encoding='utf-8') as f:
            for line in f:
                if "=" in line:
                    game_key, elf = line.strip().split("=", 1)
                    elf_name = os.path.basename(elf.replace("mass:/", ""))
                    games.append({"name": game_key, "elf": elf_name})
        html = f"""<!DOCTYPE html><html><head><title>Jogos POPStarter</title><meta charset="UTF-8"><style>body{{font-family:Arial,sans-serif;background:#222;color:#eee;margin:40px;}}h1{{color:#4a90e2;}}table{{width:100%;border-collapse:collapse;margin-top:20px;}}th,td{{padding:12px;border:1px solid #444;text-align:left;}}th{{background:#333;}}tr:nth-child(even){{background:#2a2a2a;}}</style></head><body><h1>üéÆ Lista de Jogos</h1><p>Gerado em: {datetime.datetime.now().strftime("%d/%m/%Y %H:%M:%S")}</p><table><tr><th>Nome do Jogo</th><th>Arquivo ELF</th></tr>"""
        for game in games:
            html += f"<tr><td>{game['name']}</td><td>{game['elf']}</td></tr>"
        html += "</table></body></html>"
        export_path = filedialog.asksaveasfilename(defaultextension=".html", filetypes=[("HTML", "*.html")], initialfile="jogos.html")
        if not export_path:
            return
        with open(export_path, 'w', encoding='utf-8') as f:
            f.write(html)
        self.log(f"üìä Exportado: {export_path}", "success")
        messagebox.showinfo("‚úÖ Sucesso", f"Exportado para:\n{export_path}")

    def verify_integrity(self):
        if not self.target_dir:
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Nenhuma pasta!")
            return
        self.log("üîç Verificando integridade...", "warning")
        conf_file = os.path.join(self.target_dir, "conf_apps.cfg")
        if not os.path.exists(conf_file):
            self.log("‚ùå conf_apps.cfg n√£o encontrado.", "error")
            return
        pops_dir = os.path.join(self.target_dir, POPS_DIR_NAME)
        with open(conf_file, 'r', encoding='utf-8') as f:
            for line in f:
                if "=" in line:
                    game_key, elf = line.strip().split("=", 1)
                    elf_name = os.path.basename(elf.replace("mass:/", ""))
                    elf_path = os.path.join(self.target_dir, elf_name)
                    elf_name_no_ext = get_elf_name_from_game_key(game_key, self.target_dir)
                    if not os.path.exists(elf_path):
                        self.log(f"‚ùå ELF ausente: {elf_name}", "error")
                    vcd_path = os.path.join(pops_dir, f"{elf_name_no_ext}.VCD")
                    if not os.path.exists(vcd_path):
                        self.log(f"‚ö†Ô∏è VCD ausente: {elf_name_no_ext}", "warning")
        self.log("‚úÖ Verifica√ß√£o conclu√≠da!", "success")
        messagebox.showinfo("‚úÖ Conclu√≠do", "Verifica√ß√£o finalizada!")

    def toggle_theme(self):
        self.current_theme = "light" if self.current_theme == "dark" else "dark"
        if self.current_theme == "dark":
            self.root.configure(bg=BG_COLOR)
            self.status_bar.configure(bg="#333", fg="#aaa")
        else:
            self.root.configure(bg="white")
            self.status_bar.configure(bg="#ddd", fg="#333")
        self.log(f"üé® Tema: {self.current_theme}", "success")
        config["theme"] = self.current_theme
        save_config(config)

    def toggle_retro_mode(self, event=None):
        self.retro_mode = not self.retro_mode
        if self.retro_mode:
            try:
                font = tkfont.Font(family="Press Start 2P", size=10)
                self.root.option_add("*Font", font)
            except:
                self.root.option_add("*Font", ("Courier", 10))
            self.root.configure(bg="#0f0f23")
            self.status_bar.configure(bg="#1a1a3a", fg="#00ff00")
            self.log("üïπÔ∏è MODO RETRO ATIVADO!", "success")
        else:
            self.root.option_add("*Font", ("TkDefaultFont"))
            self.toggle_theme()
            self.toggle_theme()
            self.log("üé® Modo Retro desativado.", "success")

    def show_about(self):
        messagebox.showinfo("Sobre", f"POPStation v{CURRENT_VERSION}\nGerenciador POPStarter Ultimate para PS2.\nDesenvolvido para a comunidade PS2 Homebrew.\nPressione Ctrl+Shift+R para modo RETRO!")

    def select_advanced_file(self):
        file_path = filedialog.askopenfilename(
            filetypes=[("Todos formatos suportados", "*.chd *.cue *.bin *.iso *.vcd *.gdi *.zso")]
        )
        if file_path:
            self.advanced_files = [file_path]
            self.advanced_file_label.config(text=f"Arquivo: {os.path.basename(file_path)}")
            self.log(f"üì• Arquivo selecionado: {os.path.basename(file_path)}", advanced=True)

    def select_advanced_output(self):
        folder = filedialog.askdirectory()
        if folder:
            self.advanced_output_folder = folder
            self.advanced_output_label.config(text=f"Pasta: {folder}")
            self.log(f"üìÅ Pasta de sa√≠da selecionada: {folder}", advanced=True)

    def start_advanced_conversion(self):
        if not hasattr(self, 'advanced_files') or not self.advanced_files:
            messagebox.showwarning("Aviso", "Selecione um arquivo de origem!")
            return
        if not hasattr(self, 'advanced_output_folder'):
            messagebox.showwarning("Aviso", "Selecione uma pasta de sa√≠da!")
            return
        input_file = self.advanced_files[0]
        output_format = self.output_format.get()
        input_ext = os.path.splitext(input_file)[1].lower()
        base_name = os.path.splitext(os.path.basename(input_file))[0]
        script_root = get_script_root()
        chdman_path = os.path.join(script_root, CHDMAN_EXE)
        cue2pops_path = os.path.join(script_root, CUE2POPS_EXE)
        pops2cue_path = os.path.join(script_root, POPS2CUE_EXE)
        vcd2iso_path = os.path.join(script_root, VCD2ISO_EXE)
        ziso_path = os.path.join(script_root, ZISO_EXE)
        try:
            if output_format == "chd" and input_ext in [".cue", ".iso", ".gdi"]:
                if not os.path.exists(chdman_path):
                    self.log(f"‚ùå {CHDMAN_EXE} n√£o encontrado!", "error", advanced=True)
                    return
                output_chd = os.path.join(self.advanced_output_folder, f"{base_name}.chd")
                if convert_to_chd(input_file, output_chd, lambda msg: self.log(msg, advanced=True)):
                    self.log(f"‚úÖ CHD salvo: {output_chd}", "success", advanced=True)
            elif input_ext == ".chd" and output_format == "cue_bin":
                if not os.path.exists(chdman_path):
                    self.log(f"‚ùå {CHDMAN_EXE} n√£o encontrado!", "error", advanced=True)
                    return
                self.log(f"‚ñ∂Ô∏è Convertendo {os.path.basename(input_file)} para CUE+BIN...", advanced=True)
                cue_temp, bin_temp, temp_dir = convert_chd_to_iso_temp(
                    input_file,
                    lambda msg: self.log(msg, advanced=True),
                    None
                )
                if cue_temp and bin_temp and os.path.exists(cue_temp) and os.path.exists(bin_temp):
                    dest_cue = os.path.join(self.advanced_output_folder, os.path.basename(cue_temp))
                    dest_bin = os.path.join(self.advanced_output_folder, os.path.basename(bin_temp))
                    shutil.move(cue_temp, dest_cue)
                    shutil.move(bin_temp, dest_bin)
                    self.log(f"‚úÖ Arquivos movidos para: {self.advanced_output_folder}", "success", advanced=True)
                    self.log(f"   {os.path.basename(dest_cue)}", "success", advanced=True)
                    self.log(f"   {os.path.basename(dest_bin)}", "success", advanced=True)
                else:
                    self.log("‚ùå Falha na extra√ß√£o do CHD.", "error", advanced=True)
                if 'temp_dir' in locals() and temp_dir:
                    shutil.rmtree(temp_dir, ignore_errors=True)
            elif input_ext == ".chd" and output_format == "gdi":
                if not os.path.exists(chdman_path):
                    self.log(f"‚ùå {CHDMAN_EXE} n√£o encontrado!", "error", advanced=True)
                    return
                output_gdi = os.path.join(self.advanced_output_folder, f"{base_name}.gdi")
                if convert_chd_to_gdi(input_file, output_gdi, lambda msg: self.log(msg, advanced=True)):
                    self.log(f"‚úÖ GDI salvo: {output_gdi}", "success", advanced=True)
            elif input_ext == ".chd" and output_format == "iso":
                if not os.path.exists(chdman_path):
                    self.log(f"‚ùå {CHDMAN_EXE} n√£o encontrado!", "error", advanced=True)
                    return
                output_iso = os.path.join(self.advanced_output_folder, f"{base_name}.iso")
                if convert_chd_to_iso_only(input_file, output_iso, lambda msg: self.log(msg, advanced=True)):
                    self.log(f"‚úÖ ISO salvo: {output_iso}", "success", advanced=True)
            elif input_ext == ".cue" and output_format == "vcd":
                if not os.path.exists(cue2pops_path):
                    self.log(f"‚ùå {CUE2POPS_EXE} n√£o encontrado!", "error", advanced=True)
                    return
                bin_path = os.path.splitext(input_file)[0] + ".bin"
                if not os.path.exists(bin_path):
                    self.log(f"‚ùå Arquivo BIN n√£o encontrado: {bin_path}", "error", advanced=True)
                    return
                self.log(f"‚ñ∂Ô∏è Convertendo {os.path.basename(input_file)} para VCD...", advanced=True)
                output_path = os.path.join(self.advanced_output_folder, f"{base_name}.vcd")
                if convert_cue_to_vcd(input_file, output_path, lambda msg: self.log(msg, advanced=True)):
                    self.log(f"‚úÖ VCD salvo: {output_path}", "success", advanced=True)
            elif input_ext in [".iso", ".bin"] and output_format == "vcd":
                self.log(f"‚ñ∂Ô∏è Convertendo {os.path.basename(input_file)} para VCD...", advanced=True)
                output_path = os.path.join(self.advanced_output_folder, f"{base_name}.vcd")
                convert_to_vcd(input_file, output_path, lambda msg: self.log(msg, advanced=True))
                self.log(f"‚úÖ VCD salvo: {output_path}", "success", advanced=True)
            elif input_ext == ".vcd" and output_format == "cue_bin":
                if not os.path.exists(pops2cue_path):
                    self.log(f"‚ùå {POPS2CUE_EXE} n√£o encontrado!", "error", advanced=True)
                    return
                temp_vcd = os.path.join(self.advanced_output_folder, os.path.basename(input_file))
                shutil.copy2(input_file, temp_vcd)
                self.log(f"‚ñ∂Ô∏è Convertendo {os.path.basename(temp_vcd)} para CUE+BIN...", advanced=True)
                if convert_vcd_to_cue_bin_with_pops2cue(temp_vcd, lambda msg: self.log(msg, advanced=True)):
                    output_cue = os.path.splitext(temp_vcd)[0] + ".cue"
                    output_bin = os.path.splitext(temp_vcd)[0] + ".bin"
                    self.log(f"‚úÖ CUE+BIN salvos em: {self.advanced_output_folder}", "success", advanced=True)
                    self.log(f"   {os.path.basename(output_cue)}", "success", advanced=True)
                    self.log(f"   {os.path.basename(output_bin)}", "success", advanced=True)
                    try:
                        os.remove(temp_vcd)
                        self.log(f"üóëÔ∏è Arquivo tempor√°rio deletado: {os.path.basename(temp_vcd)}", "success", advanced=True)
                    except Exception as e:
                        self.log(f"‚ö†Ô∏è N√£o foi poss√≠vel deletar o VCD tempor√°rio: {e}", "warning", advanced=True)
                else:
                    self.log("‚ùå Falha na convers√£o com POPS2CUE.EXE.", "error", advanced=True)
            elif input_ext == ".vcd" and output_format == "iso":
                if not os.path.exists(vcd2iso_path):
                    self.log(f"‚ùå {VCD2ISO_EXE} n√£o encontrado!", "error", advanced=True)
                    return
                self.log(f"‚ñ∂Ô∏è Convertendo {os.path.basename(input_file)} para ISO...", advanced=True)
                output_iso = os.path.join(self.advanced_output_folder, f"{base_name}.iso")
                if convert_vcd_to_iso(input_file, output_iso, lambda msg: self.log(msg, advanced=True)):
                    self.log(f"‚úÖ ISO salvo: {output_iso}", "success", advanced=True)
            elif input_ext == ".iso" and output_format == "zso":
                if not os.path.exists(ziso_path):
                    self.log(f"‚ùå {ZISO_EXE} n√£o encontrado! Certifique-se de que est√° na pasta do script.", "error", advanced=True)
                    return
                output_zso = os.path.join(self.advanced_output_folder, f"{base_name}.zso")
                self.log(f"‚ñ∂Ô∏è Convertendo ISO ‚Üí ZSO: {os.path.basename(input_file)}", advanced=True)
                if convert_iso_to_zso(input_file, output_zso, lambda msg: self.log(msg, advanced=True)):
                    self.log(f"‚úÖ ZSO salvo: {output_zso}", "success", advanced=True)
                else:
                    self.log("‚ùå Falha na convers√£o ISO ‚Üí ZSO.", "error", advanced=True)
            elif input_ext == ".zso" and output_format == "iso":
                if not os.path.exists(ziso_path):
                    self.log(f"‚ùå {ZISO_EXE} n√£o encontrado! Certifique-se de que est√° na pasta do script.", "error", advanced=True)
                    return
                output_iso = os.path.join(self.advanced_output_folder, f"{base_name}.iso")
                self.log(f"‚ñ∂Ô∏è Convertendo ZSO ‚Üí ISO: {os.path.basename(input_file)}", advanced=True)
                if convert_zso_to_iso(input_file, output_iso, lambda msg: self.log(msg, advanced=True)):
                    self.log(f"‚úÖ ISO salvo: {output_iso}", "success", advanced=True)
                else:
                    self.log("‚ùå Falha na convers√£o ZSO ‚Üí ISO.", "error", advanced=True)
            else:
                self.log("‚ùå Convers√£o n√£o suportada para esta combina√ß√£o.", "error", advanced=True)
                return
            try:
                winsound.PlaySound(os.path.join(script_root, "success.wav"), winsound.SND_ASYNC)
            except:
                pass
        except Exception as e:
            self.log(f"‚ùå Erro: {e}", "error", advanced=True)

    def update_usb_origin_status(self):
        script_root = get_script_root()
        usb_install_path = os.path.join(script_root, "usb_install")
        if os.path.exists(usb_install_path) and os.listdir(usb_install_path):
            self.origin_status.config(text="‚úÖ Pronto!", fg=SUCCESS_COLOR)
        elif os.path.exists(usb_install_path):
            self.origin_status.config(text="‚ö†Ô∏è Pasta vazia!", fg=WARNING_COLOR)
        else:
            self.origin_status.config(text="‚ùå Pasta 'usb_install' n√£o encontrada!", fg=ERROR_COLOR)

    def select_usb_destination(self):
        folder = filedialog.askdirectory(title="Selecione a pasta de destino no USB")
        if not folder:
            return
        self.usb_dest = folder
        self.usb_dest_label.config(text=f"üìÅ {folder}")
        self.usb_log_text.config(state="normal")
        self.usb_log_text.delete("1.0", tk.END)
        self.usb_log_text.insert("1.0", f">>> Destino selecionado: {folder}\n", "info")
        self.usb_log_text.config(state="disabled")
        self.log_usb(f"üîå Destino USB definido: {folder}", "info")

    def start_usb_install(self):
        if not hasattr(self, 'usb_dest') or not self.usb_dest:
            messagebox.showwarning("‚ö†Ô∏è Aviso", "Por favor, selecione um destino no USB!")
            return
        script_root = get_script_root()
        usb_install_path = os.path.join(script_root, "usb_install")
        if not os.path.exists(usb_install_path):
            self.log_usb("‚ùå Pasta 'usb_install' n√£o existe no diret√≥rio do script!", "error")
            return
        items = os.listdir(usb_install_path)
        if not items:
            self.log_usb("‚ö†Ô∏è A pasta 'usb_install' est√° vazia. Nada para copiar.", "warning")
            return
        total_items = len(items)
        self.log_usb(f"üöÄ Iniciando instala√ß√£o USB... ({total_items} itens)", "info")
        success_count = 0
        failed_count = 0
        skipped_count = 0
        for item in items:
            src = os.path.join(usb_install_path, item)
            dst = os.path.join(self.usb_dest, item)
            try:
                if os.path.isdir(src):
                    if os.path.exists(dst):
                        self.log_usb(f"üìÅ Mesclando pasta: {item}", "info")
                        copy_tree(src, dst, self.log)
                    else:
                        shutil.copytree(src, dst)
                        self.log_usb(f"üìÅ Copiado diret√≥rio: {item}", "success")
                else:
                    if os.path.exists(dst):
                        if os.path.getsize(src) == os.path.getsize(dst):
                            with open(src, 'rb') as f1, open(dst, 'rb') as f2:
                                if f1.read() == f2.read():
                                    self.log_usb(f"‚úÖ Ignorado (igual): {item}", "info")
                                    skipped_count += 1
                                    continue
                        shutil.copy2(src, dst)
                        self.log_usb(f"üìÑ Atualizado: {item}", "success")
                    else:
                        shutil.copy2(src, dst)
                        self.log_usb(f"üìÑ Copiado: {item}", "success")
                if sys.platform == "win32":
                    import ctypes
                    FILE_ATTRIBUTE_HIDDEN = 0x02
                    ctypes.windll.kernel32.SetFileAttributesW(dst, FILE_ATTRIBUTE_HIDDEN)
                    self.log_usb(f"üëÅÔ∏è  Ocultado: {item}", "info")
                success_count += 1
            except Exception as e:
                failed_count += 1
                self.log_usb(f"‚ùå Falha ao copiar '{item}': {str(e)}", "error")
        self.status_var.set(f"‚úÖ Conclu√≠do: {success_count} itens instalados")
        self.log_usb(f"\nüéâ INSTALA√á√ÉO CONCLU√çDA!\n   ‚úîÔ∏è Sucesso: {success_count}\n   ‚ö†Ô∏è Ignorados (iguais): {skipped_count}\n   ‚ùå Falhas: {failed_count}", "success")
        try:
            winsound.PlaySound(os.path.join(script_root, "success.wav"), winsound.SND_ASYNC)
        except:
            pass
        self.update_usb_origin_status()

    def log_usb(self, message, level="info"):
        self.usb_log_text.config(state="normal")
        tag = level
        self.usb_log_text.insert(tk.END, message + "\n", tag)
        self.usb_log_text.see(tk.END)
        self.usb_log_text.config(state="disabled")

if __name__ == "__main__":
    ensure_dir("logs")
    log_file = os.path.join("logs", "popstation.log")
    if os.path.exists(log_file):
        open(log_file, "w", encoding="utf-8").close()
    script_root = get_script_root()
    print(f"[INFO] Pasta raiz do script: {script_root}")

    # Garante que a pasta de idiomas exista
    if not os.path.exists(LANG_DIR):
        os.makedirs(LANG_DIR, exist_ok=True)

    # Carrega configura√ß√£o inicial
    config = load_config()

    root = TkinterDnD.Tk()
    app = PopsManagerGUI(root)
    root.mainloop()
```
‚îî‚îÄ‚îÄ tony-backup-config.json
```python
{
  "ignore_folders": [
    ".idea .git .venv __pycache__ _STOP"
  ],
  "ignore_files": [
    "requirements.txt SnapRestore.pyw estrutura.txt generate_project_structure.py SnapRestore üìÖ‚úÖüß†.pyw"
  ],
  "code_extensions": [
    ".py .md .txt .json .yaml .yml .css .html"
  ],
  "auto_update_check": true,
  "cloud_provider": null,
  "aws_bucket": "",
  "aws_region": "us-east-1",
  "aws_access_key": "",
  "aws_secret_key": ""
}

```
‚îî‚îÄ‚îÄ window_config.json
```python
{
  "geometry": "1100x750",
  "position": "+156+91"
}

```
‚îú‚îÄ‚îÄ backups/
‚îÇ   ‚îú‚îÄ‚îÄ Nova pasta/
‚îú‚îÄ‚îÄ FIX POPSTART/
‚îú‚îÄ‚îÄ lang/
‚îÇ   ‚îî‚îÄ‚îÄ lang\pt_BR.json
```python
{
  "btn_select_folder": "Selecionar Pasta",
  "lbl_games_count": "Jogos: {count}",
  "msg_no_folder": "Nenhuma pasta de destino selecionada.\nV√° para a aba 'Convers√£o de Jogos' e escolha uma pasta.",
  "msg_no_conf": "Arquivo 'conf_apps.cfg' n√£o encontrado.\nVoc√™ precisa processar jogos primeiro na aba 'Convers√£o'.",
  "msg_confirm_delete": "Apagar '{game_key}'?",
  "msg_success": "Sucesso",
  "msg_error": "Erro",
  "msg_warning": "Aviso",
  "btn_check_fix": "üîç Verificar e Corrigir",
  "btn_export_zip": "üíæ Compactar e Exportar para USB",
  "chk_ps1_mode": "For√ßar compatibilidade PS1 (Nomes em ISO-8859-1)",
  "btn_test_mode": "üß™ Modo de Teste",
  "btn_check_update": "üîÑ Verificar Atualiza√ß√µes",
  "update_available": "Nova vers√£o v{new_version} dispon√≠vel! Baixar em:\n{url}",
  "update_current": "Voc√™ est√° na vers√£o mais recente!",
  "recent_games": "Jogos Recentes:",
  "btn_clear_recent": "üóëÔ∏è Limpar Hist√≥rico"
}
```
‚îú‚îÄ‚îÄ logs/
‚îú‚îÄ‚îÄ usb_install/
‚îÇ   ‚îú‚îÄ‚îÄ APPS/
‚îÇ   ‚îú‚îÄ‚îÄ PS2BBL/
‚îÇ   ‚îú‚îÄ‚îÄ system_usb/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ THM/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ thm_86981192287/